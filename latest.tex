\documentclass{book}
\usepackage[english]{babel}
\usepackage{geometry,amsmath,amssymb,calc,ifthen,alltt,capt-of,makeidx}
\makeindex
\geometry{letterpaper}

%%%%%%%%%% Start TeXmacs macros
\newcommand{\assign}{:=}
\newcommand{\cdummy}{\cdot}
\newcommand{\nin}{\not\in}
\newcommand{\nobracket}{}
\newcommand{\nosymbol}{}
\newcommand{\tmcodeinline}[2][]{{\ttfamily{#2}}}
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmmathbf}[1]{\ensuremath{\boldsymbol{#1}}}
\newcommand{\tmname}[1]{\textsc{#1}}
\newcommand{\tmop}[1]{\ensuremath{\operatorname{#1}}}
\newcommand{\tmrsub}[1]{\ensuremath{_{\textrm{#1}}}}
\newcommand{\tmrsup}[1]{\textsuperscript{#1}}
\newcommand{\tmsamp}[1]{\textsf{#1}}
\newcommand{\tmstrong}[1]{\textbf{#1}}
\newcommand{\tmtextbf}[1]{{\bfseries{#1}}}
\newcommand{\tmtextit}[1]{{\itshape{#1}}}
\newcommand{\tmtextsc}[1]{{\scshape{#1}}}
\newcommand{\tmtextsf}[1]{{\sffamily{#1}}}
\newcommand{\tmtexttt}[1]{{\ttfamily{#1}}}
\newcommand{\tmverbatim}[1]{{\ttfamily{#1}}}
\newenvironment{itemizedot}{\begin{itemize} \renewcommand{\labelitemi}{$\bullet$}\renewcommand{\labelitemii}{$\bullet$}\renewcommand{\labelitemiii}{$\bullet$}\renewcommand{\labelitemiv}{$\bullet$}}{\end{itemize}}
\newenvironment{itemizeminus}{\begin{itemize} \renewcommand{\labelitemi}{$-$}\renewcommand{\labelitemii}{$-$}\renewcommand{\labelitemiii}{$-$}\renewcommand{\labelitemiv}{$-$}}{\end{itemize}}
\newenvironment{tmcode}[1][]{\begin{alltt} }{\end{alltt}}
\newcounter{tmcounter}
\newcommand{\custombinding}[1]{%
  \setcounter{tmcounter}{#1}%
  \addtocounter{tmcounter}{-1}%
  \refstepcounter{tmcounter}}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newcommand{\tmfloatcontents}{}
\newlength{\tmfloatwidth}
\newcommand{\tmfloat}[5]{
  \renewcommand{\tmfloatcontents}{#4}
  \setlength{\tmfloatwidth}{\widthof{\tmfloatcontents}+1in}
  \ifthenelse{\equal{#2}{small}}
    {\setlength{\tmfloatwidth}{0.45\linewidth}}
    {\setlength{\tmfloatwidth}{\linewidth}}
  \begin{minipage}[#1]{\tmfloatwidth}
    \begin{center}
      \tmfloatcontents
      \captionof{#3}{#5}
    \end{center}
  \end{minipage}}
%%%%%%%%%% End TeXmacs macros

\providecommand{\cdummy}{{\cdot}}
\providecommand{\nobracket}{}
\providecommand{\nosymbol}{}
\providecommand{\tmem}[1]{\tmtextit{#1}}
\providecommand{\tmname}[1]{\tmtextsc{#1}}
\providecommand{\tmop}[1]{\ensuremath{\mathrm{#1}}}
\providecommand{\tmrsub}[1]{\tmrsub{\ensuremath{\mathrm{#1}}}}
\providecommand{\tmsamp}[1]{\tmtextsf{#1}}
\providecommand{\tmstrong}[1]{\tmtextbf{#1}}
\providecommand{\tmtextbf}[1]{\tmtextbf{#1}}
\providecommand{\tmtextit}[1]{\tmtextit{#1}}
\providecommand{\tmverbatim}[1]{\tmtexttt{#1}}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
%

\newcommand{\figuretext}{Snippet}
\newcommand{\figuretext}{Figure}

\begin{document}

\title{
  Polkadot Runtime Environment\\
  {\Large Protocol Specification}
}

\date{September 14, 2019}

\maketitle

{\tableofcontents}

\chapter{Background}

\section{Introduction}

Formally, Polkadot is a replicated sharded state machine designed to resolve
the scalability and interoperability among blockchains. In Polkadot
vocabulary, shards are called {\tmem{parachains}} and Polkadot {\tmem{relay
chain}} is part of the protocol ensuring global consensus among all the
parachains. The Polkadot relay chain protocol, henceforward called
{\tmem{Polkadot protocol}}, can itself be considered as a replicated state
machine on its own. As such, the protocol can be specified by identifying the
state machine and the replication strategy.

From a more technical point of view, the Polkadot protocol has been divided
into two parts, the {\tmem{Runtime}} and the {\tmem{Runtime environment}}
(RE). The Runtime comprises most of the state transition logic for the
Polkadot protocol and is designed and expected to be upgradable as part of the
state transition process. The Runtime environment consists of parts of the
protocol,\quad shared mostly among peer-to-peer decentralized
cryptographically-secured transaction systems, i.e. blockchains whose
consensus system is based on the proof-of-stake. The RE is planned to be
stable and static for the lifetime duration of the Polkadot protocol.

With the current document, we aim to specify the RE part of the Polkadot
protocol as a replicated state machine. After defining the basic terms in
Chapter 1, we proceed to specify the representation of a valid state of the
Protocol in Chapter \ref{chap-state-spec}. In Chapter
\ref{chap-state-transit}, we identify the protocol states, by explain the
Polkadot state transition and discussing the detail based on which Polkadot RE
interacts with the state transition function, i.e. Runtime. Following, we
specify the input messages triggering the state transition and the system
behaviour. In Chapter \ref{chap-consensu}, we specify the consensus protocol,
which is responsible for keeping all the replica in the same state. Finally,
the initial state of the machine is identified and discussed in Appendix
\ref{sect-genisis-block}. A Polkadot RE implementation which conforms with
this part of the specification should successfully be able to sync its states
with the Polkadot network.

\section{Definitions and Conventions}\label{sect-defn-conv}

\begin{definition}
  \label{defn-state-machine}A {\tmstrong{Discrete State Machine (DSM)}} is a
  state transition system whose set of states and set of transitions are
  countable and admits a starting state. Formally, it is a tuple of
  \[  (\Sigma, S, s_0, \delta) \]
  where
  \begin{itemize}
    \item $\Sigma$ is the countable set of all possible transactions.
    
    \item $S$ is a countable set of all possible states.
    
    \item $s_0 \in S$ is the initial state.
    
    \item $\delta$ is the state-transition function, known as
    \label{defn-runtime}{\tmstrong{Runtime}} in the Polkadot vocabulary, such
    that
    \[ \delta : S \times \Sigma \rightarrow S \]
  \end{itemize}
\end{definition}

\begin{definition}
  \label{defn-path-graph}A {\tmstrong{path graph}} or a {\tmstrong{path}} of
  $n$ nodes formally referred to as {\tmstrong{$P_n$}}, is a tree with two
  nodes of vertex degree 1 and the other n-2 nodes of vertex degree 2.
  Therefore, $P_n$ can be represented by sequences of $(v_1, \ldots, v_n)$
  where $e_i = (v_i, v_{i + 1})$ for $1 \leqslant i \leqslant n - 1$ is the
  edge which connect $v_i$ and $v_{i + 1}$.
\end{definition}

\begin{definition}
  \label{defn-radix-tree}{\tmstrong{Radix-r tree}} is a variant of \ a trie in
  which:
  \begin{itemize}
    \item Every node has at most $r$ children where $r = 2^x$ for some $x$;
    
    \item Each node that is the only child of a parent, which does not
    represent a valid key is merged with its parent.
  \end{itemize}
\end{definition}

As a result, in a radix tree, any path whose interior vertices all have only
one child and does not represent a valid key in the data set, is compressed
into a single edge. This improves space efficiency when the key space is
sparse.

\begin{definition}
  By a {\tmstrong{sequences of bytes}} or a {\tmstrong{byte array}}, $b$, of
  length $n$, we refer to
  \[ b \assign (b_0, b_1, ..., b_{n - 1})  \text{such that } 0 \leqslant b_i
     \leqslant 255 \]
  We define $\mathbb{B}_n$ to be the {\tmstrong{set of all byte arrays of
  length $n$}}. Furthermore, we define:
  \[ \mathbb{B} \assign \bigcup^{\infty}_{i = 0} \mathbb{B}_i \]
\end{definition}

\begin{notation}
  We represent the concatenation of byte arrays $a \assign (a_0, \ldots, a_n)$
  and $b \assign (b_0, \ldots, b_m)$ by:
  \[ a || b \assign (a_0, \ldots, a_n, b_0, \ldots, b_m) \]
\end{notation}

\begin{definition}
  \label{defn-bit-rep}For a given byte $b$ the {\tmstrong{bitwise
  representation}} of $b$ is defined as
  \[ b \assign b^7 \ldots b^0 \]
  where
  \[ b = 2^0 b^0 + 2^1 b^1 + \cdots + 2^7 b^7 \]
\end{definition}

\begin{definition}
  \label{defn-little-endian}By \tmverbatim{}the {\tmstrong{little-endian}}
  representation of a non-negative integer, I, represented as
  \[ I = (B_n \ldots B_0)_{256} \]
  in base 256, we refer to a byte array $B = (b_0, b_1, \ldots, b_n)$ such
  that
  \[ b_i \assign B_i \]
  Accordingly, define the function $\tmop{Enc}_{\tmop{LE}}$:
  \[ \begin{array}{llll}
       \tmop{Enc}_{\tmop{LE}} : & \mathbb{Z}^+ & \rightarrow & \mathbb{B}\\
       & (B_n \ldots B_0)_{256} & \mapsto & (B_{0,} B_1, \ldots_{}, B_n)
     \end{array} \]
  
\end{definition}

\begin{definition}
  By {\tmname{{\tmstrong{\tmverbatim{UINT32}}}}} we refer to a non-negative
  integer stored in a byte array of length 4 using little-endian encoding
  format.
\end{definition}

\begin{definition}
  A {\tmstrong{blockchain}} $C$ is a directed path graph. Each node of the
  graph is called {\tmstrong{Block}} and indicated by {\tmstrong{$B$}}. The
  unique sink of $C$ is called {\tmstrong{Genesis Block}}, and the source is
  called the {\tmstrong{Head}} of C. For any vertex $(B_1, B_2)$ where $B_1
  \rightarrow B_2$ we say $B_2$ is the {\tmstrong{parent}} of $B_1$ and we
  indicate it by
  \[ B_2 \assign P (B_1) \]
\end{definition}

\subsection{Block Tree}

In the course of formation of a (distributed) blockchain, it is possible that
the chain forks into multiple subchains in various block positions. We refer
to this structure as a {\tmem{block tree:}}

\begin{definition}
  \label{defn-block-tree}The {\tmstrong{block tree}} of a blockchain, denoted
  by $\tmop{BT}$ is the union of all different versions of the blockchain
  observed by all the nodes in the system such as every such block is a node
  in the graph and $B_1$ is connected to $B_2$ if $B_1$ is a parent of $B_2$.
\end{definition}

When a block in the block tree gets finalized, there is an opportunity to
prune the block tree to free up resources into branches of blocks that do not
contain all of the finalized blocks or those that can never be finalized in
the blockchain. For a definition of finality, see Section \ref{sect-finality}.

\begin{definition}
  \label{defn-pruned-tree}By {\tmstrong{Pruned Block Tree}}, denoted by
  $\tmop{PBT}$, we refer to a subtree of the block tree obtained by
  eliminating all branches which do not contain the most recent finalized
  blocks, as defined in Definition \ref{defn-finalized-block}. By
  {\tmstrong{pruning}}, we refer to the procedure of $\tmop{BT} \leftarrow
  \tmop{PBT}$. When there is no risk of ambiguity and is safe to prune BT, we
  use $\tmop{BT}$ to refer to $\tmop{PBT}$.
\end{definition}

Definition \ref{defn-chain-subchain} gives the means to highlight various
branches of the block tree.

\begin{definition}
  \label{defn-chain-subchain}Let $G$ be the root of the block tree and $B$ be
  one of its nodes. By {\tmname{{\tmstrong{Chain($B$)}},}} we refer to the
  path graph from $G$ to $B$ in (P)$\tmop{BT}$. Conversely, for a chain
  $C$={\tmname{Chain(B)}}, we define {\tmstrong{the head of $C$}} to be $B$,
  formally noted as $B \assign${\tmname{Head($C$)}}. We define $| C |$, the
  length of $C$as a path graph. If $B'$ is another node on
  {\tmname{Chain($B$)}}, then by {\tmname{SubChain($B', B$)}} we refer to the
  subgraph of {\tmname{Chain($B$)}} path graph which contains both $B$ and
  $B'$. Accordingly, $\mathbb{C}_{B'} ((P) \tmop{BT})$ is the set of all
  subchains of $(P) \tmop{BT}$ rooted at $B'$. The set of all chains of $(P)
  \tmop{BT}$, $\mathbb{C}_G ((P) \tmop{BT})$ is denoted by $\mathbb{C}$((P)BT)
  or simply $\mathbb{C}$, for the sake of brevity.
\end{definition}

\begin{definition}
  \label{defn-longest-chain}We define the following complete order over
  $\mathbb{C}$ such that for $C_1, C_2 \in \mathbb{C}$ if $| C_1 | \neq | C_2
  |$ we say $C_1 > C_2$ if and only if $| C_1 | > | C_2 |$.
  
  If $| C_1 | = | C_2 |$ we say $C_1 > C_2$ if and only if the block arrival
  time of $\tmop{Head} (C_1)_{}$ is less than the block arrival time of
  $\tmop{Head} (C_2)$ as defined in Definition \ref{defn-block-time}. We
  define the {\tmstrong{{\tmname{Longest-Chain($\tmop{BT}$)}}}} to be the
  maximum chain given by this order.
\end{definition}

\begin{definition}
  {\tmname{Longest-Path($\tmop{BT}$)}} returns the path graph of $(P)
  \tmop{BT}$ which is the longest among all paths in $(P) \tmop{BT}$ and has
  the earliest block arrival time as defined in Definition
  \ref{defn-block-time}. {\tmname{Deepest-Leaf($\tmop{BT}$)}} returns the head
  of {\tmname{Longest-Path($\tmop{BT}$)}} chain.
\end{definition}

Because every block in the blockchain contains a reference to its parent, it
is easy to see that the block tree is de facto a tree. A block tree naturally
imposes partial order relationships on the blocks as follows:

\begin{definition}
  We say {\tmstrong{B is descendant of $B'$}}, formally noted as {\tmstrong{$B
  > B'$}} if $B$ is a descendant of $B'$ in the block tree.
\end{definition}

\chapter{State Specification}\label{chap-state-spec}

\section{State Storage and Storage Trie}

For storing the state of the system, Polkadot RE implements a hash table
storage where the keys are used to access each data entry. There is no
assumption either on the size of the key nor on the size of the data stored
under them, besides the fact that they are byte arrays with specific upper
limits on their length. The limit is imposed by the encoding algorithms to
store the key and the value in the storage trie.

\subsection{Accessing System Storage }

Polkadot RE implements various functions to facilitate access to the system
storage for the runtime. Section \ref{sect-runtime-api} lists all of those
functions. Here we formalize the access to the storage when it is being
directly accessed by Polkadot RE (in contrast to Polkadot runtime).

\begin{definition}
  \label{defn-stored-value}The {\tmstrong{StoredValue}} function retrieves the
  value stored under a specific key in the state storage and is formally
  defined as :
  \[ \begin{array}{cc}
       \tmop{StoredValue} : & \mathcal{K} \rightarrow \mathcal{V}\\
       & k \mapsto \left\{ \begin{array}{cc}
         v & \text{if (k,v) exists in state storage}\\
         \phi & \tmop{otherwise}
       \end{array} \right.
     \end{array} \]
  where $\mathcal{K} \subset \mathbb{B}$ and $\mathcal{V} \subset \mathbb{B}$
  are respectively the set of all keys and values stored in the state storage.
  
  \ 
\end{definition}

\subsection{The General Tree Structure}

In order to ensure the integrity of the state of the system, the stored data
needs to be re-arranged and hashed in a {\tmem{modified Merkle Patricia
Tree}}, which hereafter we refer to as the {\tmem{{\tmstrong{Trie}}}}. This
rearrangment is necessary to be able to compute the Merkle hash of the whole
or part of the state storage, consistently and efficiently at any given time.

The Trie is used to compute the {\tmem{state root}}, $H_r$, (see Definition
\ref{defn-block-header}), whose purpose is to authenticate the validity of the
state database. Thus, Polkadot RE follows a rigorous encoding algorithm to
compute the values stored in the trie nodes to ensure that the computed Merkle
hash, $H_r$, matches across the Polkadot RE implementations.

The Trie is a {\tmem{radix-16}} tree as defined in Definition
\ref{defn-radix-tree}. Each key value identifies a unique node in the tree.
However, a node in a tree might or might not be associated with a key in the
storage.

When traversing the Trie to a specific node, its key can be reconstructed by
concatenating the subsequences of the key which are stored either explicitly
in the nodes on the path or implicitly in their position as a child of their
parent.

To identify the node corresponding to a key value, $k$, first we need to
encode $k$ in a consistent with the Trie structure way. Because each node in
the trie has at most 16 children, we represent the key as a sequence of 4-bit
nibbles:

\begin{definition}
  For the purpose of labeling the branches of the Trie, the key $k$ is encoded
  to $k_{\tmop{enc}}$ using KeyEncode functions:
  \begin{equation}
    k_{\tmop{enc}} \assign (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{2 n}})
    \assign \tmop{KeyEncode} (k) \label{key-encode-in-trie}
  \end{equation}
  such that:
  \[ \tmop{KeyEncode} (k) : \left\{ \begin{array}{lll}
       \mathbb{B}^{\nosymbol} & \rightarrow & \tmop{Nibbles}^4\\
       k \assign (b_1, \ldots, b_n) \assign & \mapsto & (b^1_1, b^2_1, b_2^1,
       b^2_2, \ldots, b^1_n, b^2_n)\\
       &  & \assign (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{2 n}})
     \end{array} \right. \]
  where $\tmop{Nibble}^4$ is the set of all nibbles of 4-bit arrays and
  $b^1_i$ and $b^2_i$ are 4-bit nibbles, which are the big endian
  representations of $b_i$:
  \[ (b^1_i, b^2_i) \assign (b_i / 16, b_i \tmop{mod} 16) \]
  , where mod is the remainder and / is the integer division operators.
\end{definition}

By looking at $k_{\tmop{enc}}$ as a sequence of nibbles, one can walk the
radix tree to reach the node identifying the storage value of $k$.

\subsection{Trie Structure}

In this subsection, we specify the structure of the nodes in the Trie as well
as the Trie structure:

\begin{notation}
  We refer to the {\tmstrong{set of the nodes of Polkadot state trie}} by
  $\mathcal{N}.$ By $N \in \mathcal{N}$ to refer to an individual node in the
  trie.
\end{notation}

\begin{definition}
  \label{defn-nodetype}The State Trie is a radix-16 tree. Each Node in the
  Trie is identified with a unique key $k_N$ such that:
  \begin{itemizeminus}
    \item $k_N$ is the shared prefix of the key of all the descendants of $N$
    in the Trie.
  \end{itemizeminus}
  and, at least one of the following statements holds:
  \begin{itemizeminus}
    \item $(k_N, v)$ corresponds to an existing entry in the State Storage.
    
    \item N has more than one child.
  \end{itemizeminus}
  \tmverbatim{}Conversely, if $(k, v)$ is an entry in the State Trie then
  there is a node $N \in \mathcal{N}$ such that $k_N$=k.
\end{definition}

\begin{notation}
  A {\tmstrong{branch}} node is a node which has one child or more. A branch
  node can have at most 16 children. A {\tmstrong{leaf}} node is a childless
  node. Accordingly:
  \[ \begin{array}{c}
       \mathcal{N}_b \assign \left\{ N \in \mathcal{N}|N \text{is a branch
       node} \right\}\\
       \mathcal{N}_l \assign \left\{ N \in \mathcal{N}|N \text{is a leaf node}
       \right\}
     \end{array} \]
\end{notation}

For each Node, part of $k_N$ is built while the trie is traversed from root to
$N$ part of $k_N$ is stored in $N$ as formalized in Definition
\ref{defn-node-key}.

\begin{definition}
  \label{defn-node-key}For any $N \in \mathcal{N}$, its key $k_N$ is divided
  into an {\tmstrong{aggregated prefix key}},
  {\tmstrong{$\tmop{pk}_N^{\tmop{Agr}}$}}, aggregated by Algorithm
  \ref{algo-aggregate-key} and a {\tmstrong{partial key}},
  {\tmstrong{$\tmop{pk}_N$}} of length $0 \leqslant l_{\tmop{pk}_N} \leqslant
  65535$ in nibbles such that:
  \[ \tmop{pk}_N \assign (k_{\tmop{enc}_i}, \ldots, k_{\tmop{enc}_{i +
     l_{\tmop{pk}_N}}}) \]
  where $\tmop{pk}_N$ is a suffix subsequence of $k_N$; $i$ is the length of
  $\tmop{pk}_N^{\tmop{Agr}}$ in nibbles and so we have:
  \[ \tmop{KeyEncode} (k_N) = \tmop{pk}_N^{\tmop{Agr}} | | \tmop{pk}_N =
     (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{i - 1}}, k_{\tmop{enc}_i},
     k_{\tmop{enc}_{i + l_{\tmop{pk}_N}}}) \]
\end{definition}

Part of $\tmop{pk}_N^{\tmop{Agr}}$ is explicitly stored in $N$'s ancestors.
Additionally, for each ancestor, a single nibble is implicitly derived while
traversing from the ancestor to its child included in the traversal path using
the $\tmop{Index}_N$ function defined in Definition \ref{defn-index-function}.

\begin{definition}
  \label{defn-index-function}For $N \in \mathcal{N}_b$ and $N_c$ child of N,
  we define {\tmstrong{$\tmop{Index}_N$}} function as:
  \[ \begin{array}{cc}
       \tmop{Index}_N : & \left\{ N_c \in \mathcal{N}|N_c  \text{is a child of
       N} \right\} \rightarrow \tmop{Nibbles}^4_1\\
       & N_c \mapsto i_{}
     \end{array} \]
  such that
  \[ k_{N_c} = k_N | | i | | \tmop{pk}_{N_c} \]
\end{definition}

Assuming that $P_N$ is the path (see Definition \ref{defn-path-graph}) from
the Trie root to node $N$, Algorithm \ref{algo-aggregate-key} rigorously
demonstrates how to build $\tmop{pk}^{\tmop{Agr}}_N$ while traversing $P_N$.

\custombinding{1}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  1. }
  \label{algo-aggregate-key}{\tmname{Aggregate-Key}}$(P_N : = (\tmop{TrieRoot}
  = N_1, \ldots, N_j = N))$\\
  \hline
\end{tabular}

{\algorithmic{{\state{$\tmop{pk}^{\tmop{Agr}}_N \leftarrow \phi$}}

{\state{$i \leftarrow 1$}}

{\state{{\WHILE{$(N_i \neq N)$}}}}

{\state{$\tmop{pk}^{\tmop{Agr}}_N \leftarrow \tmop{pk}^{\tmop{Agr}}_N | |
\tmop{pk}_{N_i} $}}

{\state{$\tmop{pk}^{\tmop{Agr}}_N \leftarrow \tmop{pk}^{\tmop{Agr}}_N | |
\tmop{Index}_{N_i} (N_{i + 1})$}}

{\state{$i \leftarrow i + 1${\END}}}

{\state{$\tmop{pk}^{\tmop{Agr}}_N \leftarrow \tmop{pk}^{\tmop{Agr}}_N | |
\tmop{pk}_{N_i}$}}

{\state{{\RETURN{$\tmop{pk}^{\tmop{Agr}}_N$}}}}}}

\hrulefill{\medskip}

\begin{definition}
  \label{defn-node-value}A node $N \in \mathcal{N}$ stores the {\tmstrong{node
  value}}, {\tmstrong{$v_N$}}, which consists of the following concatenated
  data:
  \[ \begin{array}{|l|l|l|}
       \hline
       \tmop{Node} \tmop{Header} & \tmop{Partial} \tmop{key} & \tmop{Node}
       \tmop{Subvalue}\\
       \hline
     \end{array} \]
  Formally noted as:
  \[ v_N \assign \tmop{Head}_N | | \tmop{Enc}_{\tmop{HE}} (\tmop{pk}_N) | |
     \tmop{sv}_N \]
  where $\tmop{Head}_N$, $\tmop{pk}_N$, $\tmop{Enc}_{\tmop{nibbles}}$ and
  $\tmop{sv}_N$ are defined in Definitions \ref{defn-node-header},
  \ref{defn-node-key}, \ref{defn-hex-encoding} and \ref{defn-node-subvalue},
  respectively.
\end{definition}

\begin{definition}
  \label{defn-node-header}The {\tmstrong{node header}} of node $N$,
  $\tmop{Head}_N$, consists of $l + 1 \geqslant 1$ bytes $\tmop{Head}_{N, 1},
  \ldots, \tmop{Head}_{N, l + 1}$ such that:
  
  
  \[ \begin{array}{ll}
       \hline
       \tmop{Node} \tmop{Type} & \tmop{pk} \tmop{length}\\
       \hline
       \tmop{Head}_{N, 1}^{6 - 7}_{} & \tmop{Head}_{N, 1}^{0 - 5}_{}
     \end{array}  \begin{array}{|l|}
       \hline
       \tmop{pk} \tmop{length} \tmop{extra} \tmop{byte} 1\\
       \hline
       \tmop{Head}_{N, 2}\\
       \hline
     \end{array}  \begin{array}{|l|}
       \hline
       \tmop{pk} \tmop{key} \tmop{length} \tmop{extra} \tmop{byte} 2\\
       \hline
       \ldots .\\
       \hline
     \end{array} \ldots \begin{array}{|l|}
       \hline
       \tmop{pk} \tmop{length} \tmop{extra} \tmop{byte} l\\
       \hline
       \tmop{Head}_{N, l + 1}^{}_{}\\
       \hline
     \end{array} \]
  
  
  In which $\tmop{Head}_{N, 1}^{6 - 7}_{}$, the two most significant bits of
  the first byte of $\tmop{Head}_N$ are determined as follows:
  \[ \tmop{Head}_{N, 1}^{6 - 7}_{} \assign \left\{ \begin{array}{ll}
       00 & \tmop{Special} \tmop{case}\\
       01 & \tmop{Leaf} \tmop{Node}\\
       10 & \tmop{Branch} \tmop{Node} \tmop{with} k_N \nin \mathcal{K}\\
       11 & \tmop{Branch} \tmop{Node} \tmop{with} k_N \in \mathcal{K}
     \end{array} \right. \]
  where $\mathcal{K}$ is defined in Definition \ref{defn-stored-value}.
  
  $\tmop{Head}_{N, 1}^{0 - 5}_{}$, the 6 least significant bits of the first
  byte of $\tmop{Head}_N$ are defined to be:
  \[ \tmop{Head}_{N, 1}^{0 - 5}_{} \assign \left\{ \begin{array}{ll}
       \| \tmop{pk}_N \|_{\tmop{nib}} & \| \tmop{pk}_N \|_{\tmop{nib}} < 63\\
       63 & \| \tmop{pk}_N \|_{\tmop{nib}} \geqslant 63
     \end{array} \right. \]
  In which {\tmstrong{$\| \tmop{pk}_N \|_{\tmop{nib}}$}} is the length of
  $\tmop{pk}_N $ in number nibbles. $\tmop{Head}_{N, 2}, \ldots,
  \tmop{Head}_{N, l + 1}$ bytes are determined by Algorithm
  \ref{algo-pk-length}.
\end{definition}

\custombinding{2}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  2. }
  \label{algo-pk-length}{\tmname{Partial-Key-Length-Encoding$(\tmop{Head}_{N,
  1}^{6 - 7}_{}, \tmop{pk}_N)$}}\\
  \hline
\end{tabular}

{\algorithmic{{\state{{\IF{$\| \tmop{pk}_N \|_{\tmop{nib}} \geqslant
2^{16}$}}}}

{\state{{\RETURN{Error{\END}}}}}

{\state{$\tmop{Head}_{N, 1} \leftarrow 64 \times \tmop{Head}_{N, 1}^{6 -
7}_{}$}}

{\state{{\IF{$\| \tmop{pk}_N \|_{\tmop{nib}} < 63$}}}}

{\state{$\tmop{Head}_{N, 1} \leftarrow \tmop{Head}_{N, 1} + \| \tmop{pk}_N
\|_{\tmop{nib}}$}}

{\state{{\RETURN{$\tmop{Head}_N \END$}}}}

{\state{$\tmop{Head}_{N, 1} \leftarrow \tmop{Head}_{N, 1} + 63$}}

{\state{$l \leftarrow \| \tmop{pk}_N \|_{\tmop{nib}} - 63$}}

{\state{$i \leftarrow 2$}}

{\state{{\WHILE{$(l > 255)$}}}}

{\state{$\tmop{Head}_{N, i} \leftarrow 255$}}

{\state{$l \leftarrow l - 255$}}

{\state{$i \leftarrow i + 1 \END$}}

{\state{$\tmop{Head}_{N, i} \leftarrow l$}}

{\state{{\RETURN{$\tmop{Head}_N$}}}}}}

\hrulefill{\medskip}

\subsection{Merkle Proof}\label{sect-merkl-proof}

To prove the consistency of the state storage across the network and its
modifications both efficiently and effectively, the Trie implements a Merkle
tree structure. The hash value corresponding to each node needs to be computed
rigorously to make the inter-implementation data integrity possible.

The Merkle value of each node should depend on the Merkle value of all its
children as well as on its corresponding data in the state storage. This
recursive dependancy is encompassed into the subvalue part of the node value
which recursively depends on the Merkle value of its children.

We use the auxilary function introduced in Definition
\ref{defn-children-bitmap} to encode and decode information stored in a branch
node.

\begin{definition}
  \label{defn-children-bitmap}Suppose $N_b, N_c \in \mathcal{N}$ and $N_c$ is
  a child of $N_b$. We define where bit $b_i : = 1$ if $N$ has a child with
  partial key $i$, therefore we define {\tmstrong{ChildrenBitmap}} functions
  as follows:
  \[ \begin{array}{cc}
       \tmop{ChildrenBitmap} : & \mathcal{N}_b \rightarrow \mathbb{B}_2\\
       & N \mapsto (b_{15}, \ldots, b_8, b_7, \ldots b_0)_2
     \end{array} \]
  where
  \[ b_i \assign \left\{ \begin{array}{cc}
       1 & \exists N_c \in \mathcal{N}: k_{N_c} = k_{N_b} | | i | |
       \tmop{pk}_{N_c}\\
       0 & \text{otherwise}
     \end{array} \right. \]
\end{definition}

\tmverbatim{}

\begin{definition}
  \label{defn-node-subvalue}For a given node $N$, the {\tmstrong{subvalue}} of
  $N$, formally referred to as $\tmop{sv}_N$, is determined as follows: in a
  case which:
  \begin{itemize}
    \[ \begin{array}{l}
         \tmop{sv}_N \assign\\
         \left\{ \begin{array}{cc}
           \tmop{Enc}_{\tmop{SC}} (\tmop{StoredValue} (k_N)) & \text{N is a
           leaf node}\\
           \nobracket \tmop{ChildrenBitmap} (N)\| \tmop{Enc}_{\tmop{SC}} (H
           (N_{C_1})) \ldots \tmop{Enc}_{\tmop{SC}} (H (N_{C_n})) | |
           \tmop{Enc}_{\tmop{SC}} (\tmop{StoredValue} (k_N))  & \text{N is a
           branch node}
         \end{array} \right.
       \end{array} \]
  \end{itemize}
\end{definition}

Where $N_{C_1} \ldots N_{C_n}$ with $n \leqslant 16$ are the children nodes of
the branch node $N$ and Enc\tmrsub{SC}, $\tmop{StoredValue}$, $H$, and
$\tmop{ChildrenBitmap} (N)$ are defined in Definitions \ref{sect-scale-codec},
\ref{defn-stored-value}, \ref{defn-merkle-value} and
\ref{defn-children-bitmap} respectively.

\

The Trie deviates from a traditional Merkle tree where node value, $v_N$ (see
Definition \ref{defn-node-value}) is presented instead of its hash if it
occupies less space than its hash.

\begin{definition}
  \label{defn-merkle-value}For a given node $N$, the {\tmstrong{Merkle value}}
  of $N$, denoted by $H (N)$ is defined as follows:
  \[ \begin{array}{ll}
       & H : \mathbb{B} \rightarrow \mathbb{B}_{32}\\
       & H (N) : \left\{ \begin{array}{lcl}
         v_N &  & \|v_N \|< 32\\
         \tmop{Blake} 2 b (v_N) &  & \|v_N \| \geqslant 32
       \end{array} \right.
     \end{array} \]
  Where $v_N$ is the node value of $N$ defined in Definition
  \ref{defn-node-value} and $0_{32 - \| v_N \|}$ an all zero byte array of
  length $32 - | | v_N | |$. The {\tmstrong{Merkle hash}} of the Trie is
  defined as:
  \[ \tmop{Blake} 2 b (H (R)) \]
  Where $R$ is the root of the Trie.
\end{definition}

\chapter{State Transition}\label{chap-state-transit}

Like any transaction-based transition system, Polkadot state changes via an
executing ordered set of instructions. These instructions are known as
{\tmem{extrinsics}}. In Polkadot, the execution logic of the state-transition
function is encapsulated in Runtime as defined in Definition
\ref{defn-state-machine}. Runtime is presented as a Wasm blob in(if?) ordered
be easily upgradable. Nonetheless, the Polkadot Runtime Environment needs to
be in constant interaction with Runtime. The detail of such interaction is
further described in Section \ref{sect-entries-into-runtime}.

In Section \ref{sect-extrinsics}, we specify the procedure of the process
where the extrinsics are submitted, pre-processed and validated by Runtime and
queued to be applied to the current state.

Polkadot, likewise most prominent distributed ledger systems that make state
replication feasible, journals and batches a series of extrinsics together in
a structure knows as a {\tmem{block}} before propagating to the other nodes.
The specification of the Polkadot block as well the process of verifying its
validity are both explained in Section \ref{sect-state-replication}.

\section{Interactions with Runtime}\label{sect-entries-into-runtime}

Runtime as defined in Definition \ref{defn-runtime} is the code implementing
the logic of the chain. This code is decoupled from the Polkadot RE to make
the Runtime easily upgradable without the need to upgrade the Polkadot RE
itself. The general procedure to interact with Runtime is described in
Algorithm \ref{algo-runtime-interaction}.

\custombinding{3}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  3. }
  \label{algo-runtime-interaction}{\tmname{Interact-With-Runtime}}($F$: the
  runtime entry,
  
  $H_b (B)$: Block hash indicating the state at the end of $B$,
  
  $A_1, A_2, \ldots, A_n$: arguments to be passed to the runtime entry)\\
  \hline
\end{tabular}

{\algorithmic{{\state{{\tmname{$\mathcal{S}_B \leftarrow$Storage-At-State($H_b
(B)$)}}}}

{\state{$A \leftarrow \tmop{Enc}_{\tmop{SC}} ((A_1, \ldots, A_n))$}}

{\state{$\text{{\tmname{Call-Runtime-Entry}}} (R_B, \mathcal{R}\mathcal{E}_B,
F, A, A_{\tmop{len}})$}}}}

\hrulefill{\medskip}

In this section, we describe the details upon which the Polkadot RE is
interacting with the Runtime. In particular, {\tmname{Storage-At-State}} and
{\tmname{Call-Runtime-Entry}} procedures called in Algorithm
\ref{algo-runtime-interaction} are explained in Notation
\ref{nota-call-into-runtime} and Definition \ref{defn-storage-at-state}
respectively. $R_B$ is the Runtime code loaded from $\mathcal{S}_B$, as
described in Notation \ref{nota-runtime-code-at-state}, and
$\mathcal{R}\mathcal{E}_B$ is the Polkadot RE API, as described in Notation
\ref{nota-re-api-at-state}.

\subsection{Loading the Runtime Code \ \ }\label{sect-loading-runtime-code}

Polkadot RE expects to receive the code for the Runtime of the chain as a
compiled WebAssembly (Wasm) Blob. The current runtime is stored in the state
database under the key represented as a byte array:
\[ b \assign \text{3A,63,6F,64,65} \]
which is the byte array of ASCII representation of string ``:code'' (see
Section \ref{sect-predef-storage-keys}). For any call to the Runtime, Polkadot
RE makes sure that it has the Runtime corresponding to the state in which the
entry has been called. This is, in part, because the calls to Runtime have
potentially the ability to change the Runtime code and hence Runtime code is
state sensitive. Accordingly, we introduce the following notation to refer to
the Runtime code at a specific state:

\begin{notation}
  \label{nota-runtime-code-at-state}By $R_B$, we refer to the Runtime code
  stored in the state storage whose state is set at the end of the execution
  of block $B$.
\end{notation}

The initial runtime code of the chain is embedded as an extrinsics into the
chain initialization JSON file and is submitted to Polkadot RE (see Section
\ref{sect-genisis-block}).

Subsequent calls to the runtime have the ability to call the storage API (see
Section \ref{sect-runtime-api}) to insert a new Wasm blob into runtime storage
slot to upgrade the runtime.

\subsection{Code Executor}

Polkadot RE provides a Wasm Virtual Machine (VM) to run the Runtime. The Wasm
VM exposes the Polkadot RE API to the Runtime, which, on its turn, executes a
call to the Runtime entries stored in the Wasm module. This part of the
Runtime environment is referred to as the {\tmem{{\tmstrong{Executor}}.}}

Definition \ref{nota-call-into-runtime} introduces the notation for calling
the runtime entry which is used whenever an algorithm of Polkadot RE needs to
access the runtime.

\begin{notation}
  \label{nota-call-into-runtime} By
  \[ \text{{\tmname{Call-Runtime-Entry}}} \left( R, \mathcal{R}\mathcal{E},
     \text{\tmverbatim{Runtime-Entry}}, A, A_{\tmop{len}} \right) \]
  we refer to the task using the executor to invoke the
  \tmverbatim{Runtime-Entry} while passing an $A_1, \ldots, A_n$ argument to
  it and using the encoding described in Section
  \ref{sect-send-args-to-runtime}.
\end{notation}

In this section, we specify the general setup for an Executor call into the
Runtime. In Section \ref{sect-runtime-entries} we specify the parameters and
the return values of each Runtime entry separately.

\subsubsection{Access to Runtime API}

When Polkadot RE calls a Runtime entry it should make sure Runtime has access
to the all Polkadot Runtime API functions described in Appendix
\ref{sect-runtime-api}. This can be done for example by loading another Wasm
module alongside the runtime which imports these functions from Polkadot RE as
host functions.

\subsubsection{Sending Arguments to Runtime
}\label{sect-runtime-send-args-to-runtime-enteries}

In general, all data exchanged between Polkadot RE and the Runtime is encoded
using SCALE codec described in Section \ref{sect-scale-codec}. As a Wasm
function, all runtime entries have the following identical signatures:

\

\tmcodeinline[cpp]{\tmverbatim{}(func \$runtime\_entry (param \$data i32)
(param \$len i32) (result i64))}

\

In each invocation of a Runtime entry, the argument(s) which are supposed to
be sent to the entry, need to be encoded using SCALE codec into a byte array
$B$ using the procedure defined in Definition \ref{sect-scale-codec}.

The Executor then needs to retrieve the Wam memory buffer of the Runtime Wasm
module and extend it to fit the size of the byte array. Afterwards, it needs
to copy the byte array $B$ value in the correct offset of the extended buffer.
Finally, when the Wasm method \tmverbatim{runtime\_entry}, corresponding to
the entry is invoked, two UINT32 integers are sent to the method as arguments.
The first argument \tmverbatim{data} is set to the offset where the byte array
$B$ is stored in the Wasm the extended shared memory buffer. The second
argument \tmverbatim{len} sets the length of the data stored in $B$., and the
second one is the size of $B$.

\subsubsection{The Return Value from a Runtime
Entry}\label{sect-runtime-return-value}

The value which is returned from the invocation is an \tmverbatim{i64}
integer, representing two consecutive \tmverbatim{i32} integers in which the
least significant one indicates the pointer to the offset of the result
returned by the entry encoded in SCALE codec in the memory buffer. The most
significant one provides the size of the blob.

In the case that the runtime entry is returning a boolean value, then the
SCALEd (boolean) value returns in the least significant byte and all other
bytes are set to zero.

\section{Extrinsics}\label{sect-extrinsics}

The block body consists of an array of extrinsics. Nonetheless, Polkadot RE
does not specify or limit the internals of each extrinsics. From Polkadot RE
point of view, each extrinsics is simply a SCALE-encoded byte array (see
Definition \ref{defn-scale-byte-array}).

\subsection{Preliminaries}

\begin{definition}
  \label{defn-account-key}{\tmstrong{Account key $(\tmop{sk}^a,
  \tmop{pk}^a)$}} is a pair of Ristretto SR25519 used to sign extrinsics among
  other accounts and blance-related functions.
\end{definition}

\subsection{Extrinsics Submission}

Extrinsic submission is made by sending a {\tmem{Transactions}} network
message. The structure of this message is specified in Section
\ref{sect-msg-transactions}. Upon receiving a Transactions message, Polkadot
RE decodes the transaction and calls \tmverbatim{validate\_trasaction} runtime
function, defined in Section \ref{sect-validate-transaction}, to check the
validity of the extrinsic. If \tmverbatim{validate\_transaction} considers the
submitted extrinsics as a valid one, Polkadot RE makes the extrinsics
available for the consensus engine for inclusion in future blocks.

\subsection{Transaction Queue}

A Block producer node should listen to all transaction
messages{\tmem{{\index{Transaction Message}}}}. This is because the
transactions are submitted to the node through the {\tmem{transactions}}
network message specified in Section \ref{sect-msg-transactions}. Upon
receiving a transactions message, Polkadot RE separates the submitted
transactions in the transactions message into individual extrinsics and passes
them to the Runtime by executing Algorithm \ref{algo-validate-transactions} to
validate and store them for inclusion into future blocks. To that aim,
Polkodot RE should keep a {\tmem{transaction pool{\index{transaction pool}}}}
and a {\tmem{transaction queue}}{\index{transaction queue}} defined as
follows:

\begin{definition}
  The {\tmstrong{Transaction Queue}} of a block producer node, formally
  referred to as $\tmop{TQ}$ is a data structure which stores the transactions
  ready to be included in a block sorted according to their priorities. The
  {\tmstrong{Transaction Pool}}, formally referred to as $\tmop{TP}$, is a
  hash table in which Polkadot RE keeps the list of all valid transactions not
  in the transaction queue. \ 
\end{definition}

Algorithm \ref{algo-validate-transactions} updates the transaction pool and
the transaction queue according to the received message:

\custombinding{4}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  4. }
  \label{algo-validate-transactions}{\tmname{Validate-Extrinsics-and-Store}}($M_T
  :$Transaction Message)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$L \leftarrow \tmop{Dec}_{\tmop{SC}} (M_T)$}}

{\state{{\FORIN{$T$}{$L$}}{\tmstrong{such that}} $E \nin \tmop{TQ}$
{\tmstrong{and}} $E \nin \tmop{TP}$:}}

{\state{$B_d \leftarrow${\tmname{Head(Longest-Chain(($\tmop{BT}$))}}}}

{\state{$N \leftarrow H_n (B_d)$}}

{\state{$R \leftarrow${\tmname{Call-Runtime-Entry}}$\left(
\text{\tmverbatim{TaggedTransactionQueue\_validate\_transaction}}, N, T
\right)$}}

{\state{{\IF{$R$ indicates $E$ is $\tmop{Valid} :$}}}}

{\state{{\IF{$\tmop{Requires}$(R){\subset}}}

\quad$\bigcup_{\forall T \in (\tmop{TQ})}${\tmname{Provided-Tags}}(T) {\cup}
$\bigcup_{i < d, \forall T, T \in B_i}${\tmname{Provided-Tags(T)}}:}}

{\state{{\tmname{Insert-At(}}$\tmop{TQ}, T, \tmop{Requires} (R),
\tmop{Priority} (R)$){\END}}}

{\state{{\ELSE{\ }}}}

{\state{{\tmname{Add-To(TP,$T$)}}{\END}}}

{\state{{\tmname{Maintain-Transaction-Pool}}}}

{\state{{\IF{Propagate(R)={\tmstrong{True}}:}}}}

{\state{{\tmname{Propagate(}}$T$){\END}{\END}{\END}}}}}

\hrulefill{\medskip}

In which
\begin{itemizeminus}
  \item {\tmname{Longest-Chain}} is defined in Definition
  \ref{defn-longest-chain}.
  
  \item \tmverbatim{TaggedTransactionQueue\_validate\_transaction} is a
  Runtime entry specified in Section \ref{sect-rte-validate-transaction} and
  Requires(R), Priority(R) and Propagate(R) refer to the corresponding fields
  in the tuple returned by the entry when it deems that $T$ is valid.
  
  \item {\tmname{Provided-Tags}}(T) is the list of tags that transaction $T$
  provides. Polkadot RE needs to keep track of tags that transaction $T$
  provides as well as requires after validating it.
  
  \item {\tmname{Insert-At(}}$\tmop{TQ}, T, \tmop{Requires} (R),
  \tmop{Priority} (R)$) places $T$ into $\tmop{TQ}$ approperietly such that
  the transactions providing the tags which $T$ requires or have higher
  priority than $T$ are ahead of $T$.
  
  \item {\tmname{Maintain-Transaction-Pool}} is described in Algorithm
  \ref{algo-maintain-transaction-pool}.
  
  \item {\tmname{Propagate(}}$T$) include $T$ in the next {\tmem{transactions
  message{\index{Transaction Message}}}} sent to all peers of Polkadot RE
  node.
\end{itemizeminus}
\custombinding{5}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  5. }
  \label{algo-maintain-transaction-pool}{\tmname{Maintain-Transaction-Pool}}\\
  \hline
\end{tabular}

{\algorithmic{{\todo{This is scaning the pool for ready transactions and
moving them to the TQ and dropping transactions which are not valid}}}}

\hrulefill{\medskip}

\section{State Replication}\label{sect-state-replication}

Polkadot nodes replicate each other's state by syncing the history of the
extrinsics. This, however, is only practical if a large set of transactions
are batched and synced at the time. The structure in which the transactions
are journaled and propagated is known as a block (of extrinsics).

\subsection{Block Format}\label{sect-block-format}

In Polkadot RE, a block is made of two main parts, namely the \tmtextit{block
header} and the \tmtextit{list of extrinsics}. {\tmem{The Extrinsics}}
represent the generalization of the concept of {\tmem{transaction}},
containing any set of data that is external to the system, and which the
underlying chain wishes to validate and keep track of.

\subsubsection{Block Header}\label{block}

The block header is designed to be minimalistic in order to boost the
efficiency of the light clients. It is defined formally as follows:

\begin{definition}
  \label{defn-block-header}The {\tmstrong{header of block B}},
  {\tmstrong{$\tmop{Head} (B)$}} is a 5-tuple containing the following
  elements:
  \begin{itemize}
    \item \tmtextbf{{\tmsamp{parent\_hash:}}} is the 32-byte Blake2b hash (see
    Section \ref{sect-blake2}) of the header of the parent of the block
    indicated henceforth by \tmtextbf{$H_p$}.
    
    \item {\tmstrong{{\tmsamp{number:}}}} formally indicated as
    {\tmstrong{$H_i$}} is an integer, which represents the index of the
    current block in the chain. It is equal to the number of the ancestor
    blocks. The genesis block has number 0.
    
    \item {\tmstrong{{\tmsamp{state\_root:}}}} formally indicated as
    {\tmstrong{$H_r$}} is the root of the Merkle trie, whose leaves implement
    the storage for the system.
    
    \item {\tmstrong{{\tmsamp{extrinsics\_root:}}}} is the field which is
    reserved for the Runtime to validate the integrity of the extrinsics
    composing the block body. For example, it can hold the root hash of the
    Merkle trie which stores an ordered list of the extrinsics being validated
    in this block. The {\tmsamp{extrinsics\_root}} is set by the runtime and
    its value is opaque to Polkadot RE. This element is formally referred to
    as {\tmstrong{$H_e$}}.
    
    \item {\tmstrong{{\tmsamp{digest:}}}} this field is used to store any
    chain-specific auxiliary data, which could help the light clients interact
    with the block without the need of accessing the full storage. Polkadot RE
    does not impose any limitation or specification for this field.
    Essentially, it can be a byte array of any length. This field is indicated
    as {\tmstrong{$H_d$}}
  \end{itemize}
\end{definition}

\begin{definition}
  \label{defn-block-header-hash}The {\tmstrong{Block Header Hash of Block
  $B$}}, {\tmstrong{$H_h (B)$}}, is the hash of the header of block $B$
  encoded by simple codec:''
  \[ H_h (B) \assign \tmop{Blake} 2 b (\tmop{Enc}_{\tmop{SC}} (\tmop{Head}
     (B))) \]
\end{definition}

\subsubsection{Justified Block Header}

The Justified Block Header is provided by the consensus engine and presented
to the Polkadot RE, for the block to be appended to the blockchain. It
contains the following parts:
\begin{itemize}
  \item {\tmstrong{{\tmsamp{{\tmstrong{block\_header}}}}}} the complete block
  header as defined in Section \ref{block} and denoted by $\tmop{Head} (B)$.
  
  \item {\tmstrong{{\tmsamp{justification}}}}: as defined by the consensus
  specification indicated by $\tmop{Just} (B)$ {\todo{link this to its
  definition from consensus}}.
  
  \item {\tmstrong{{\tmsamp{authority Ids}}}}: This is the list of the Ids of
  authorities, which have voted for the block to be stored and is formally
  referred to as $A (B)$. An authority Id is 32bit.
\end{itemize}

\subsubsection{Block Inherent Data}

Block inherent data represent the totality of extrinsics included in each
block. In general, these data are collected or generated by Polkadot RE and
handed to Runtime for inclusion in the block. Table \ref{tabl-inherent-data}
lists these inherent data, their identifiers, and types.

\begin{table}[h]
  \begin{tabular}{lll}
    \hline
    Identifier & Type  & Description\\
    \hline
    timstap0 & u64 & Unix epoch time in number of seconds\\
    babeslot & u64 & Babe Slot Number\tmrsup{\ref{defn-epoch-slot}}\\
    \hline
  \end{tabular}
  \caption{\label{tabl-inherent-data}List of inherent data}
\end{table}

\begin{definition}
  \label{defn-func-inherent-data}The function
  {\tmname{Block-Inherents-Data($B_n$)}} return the inherent data defined in
  Table \ref{tabl-inherent-data} corresponding to Block $B$ as a SCALE encoded
  dictionary as defined in Definition \ref{defn-scale-list}.
\end{definition}

\subsubsection{Block Body}\label{sect-block-body}

The Block Body consists of array extrinsics each encoded as a byte array. The
internal of extrinsics is completely opaque to Polkadot RE. As such, it forms
the point of Polkadot RE, and is simply a SCALE encoded array of byte arrays.
Formally:

\begin{definition}
  \label{defn-block-body}The {\tmstrong{body of Block}} $B$ represented as
  {\tmstrong{$\tmop{Body} (B)$}} is defined to be
  \[ \tmop{Body} (B) \assign \tmop{Enc}_{\tmop{SC}} (E_1, \ldots, E_n) \]
  Where each $E_i \in \mathbb{B}$ is a SCALE encoded extrinsic.
\end{definition}

\subsection{Block Submission}

Block validation is the process by which the client asserts that a block is
fit to be added to the blockchain. This means that the block is consistent
with the world state and transitions from the state of the system to a new
valid state.

Blocks can be handed to the Polkadot RE both from the network stack for
example by means of Block response network message (see Section
\ref{sect-msg-block-response} ) and from the consensus engine.

\subsection{Block Validation}

Both the Runtime and the Polkadot RE need to work together to assure block
validity. A block is deemed valid if the block author had the authorship right
for the slot during which the slot was built as well as if the transactions in
the block constitute a valid transition of states. The former criterion is
validated by Polkadot RE according to the block production consensus protocol.
The latter can be verified by Polkadot RE invoking \tmverbatim{execute\_block}
entry into the Runtime as a part of the validation process.

Polkadot RE implements the following procedure to assure the validity of the
block:

\custombinding{6}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  6. } {\tmname{Import-and-Validate-Block($B, \tmop{Just}
  (B)$)}}\\
  \hline
\end{tabular}

{\algorithmic{{\state{{\IF{$\tmop{Just} (B) \neq \emptyset$}}}}

{\state{{\tmname{Verify-Block-Justification}}$(B, \tmop{Just} (B))$}}

{\state{{\IF{$B$ {\tmstrong{is}} Finalized {\tmstrong{and}} $P (B)$
{\tmstrong{is not}} Finalized}}}}

{\state{{\tmname{Mark-as-Final}}$(P (B))${\END}{\END}}}

{\state{{\IF{$H_p (B) \nin \tmop{PBT}$}}}}

{\state{{\RETURN{{\END}}}}}

{\state{{\tmname{Verify-Authorship-Right}}($\tmop{Head} (B)$)}}

{\state{$S \leftarrow$ {\tmname{Call-Runtime-Entry}}$\left(
\text{\tmverbatim{Core\_execute\_block}}, B \right)$}}

{\state{{\tmname{Update-World-State}}($S$)}}}}

\hrulefill{\medskip}

For the definition of the finality and the finalized block see Section
\ref{sect-finality}. $\tmop{PBT}$ is the pruned block tree defined in
Definition \ref{defn-block-tree}. {\tmname{Verify-Authorship-Right}} is part
of the block production consensus protocol and is described in Algorithm
\ref{algo-verify-authorship-right}.

\section{Network Interactions}\label{sect-network-interactions}

\chapter{Consensus}\label{chap-consensu}

Consensus in Polkadot RE is achieved during the execution of two different
procedures. The first procedure is block production and the second is
finality. Polkadot RE must run these procedures, if and only if it is running
on a validator node.

\section{Block Production}\label{sect-babe}\label{sect-block-production}

Polkadot RE uses BABE protocol {\cite{w3f_research_group_blind_2019}} for
block production designed based on Ouroboros praos
{\cite{david_ouroboros_2018}}. BABE execution happens in sequential
non-overlapping phases known as an {\tmstrong{{\tmem{epoch}}}}. Each epoch on
its turn is divided into a predefined number of slots. All slots in each epoch
are sequentially indexed starting from 0. At the beginning of each epoch, the
BABE node needs to run Algorithm \ref{algo-block-production-lottery} to find
out in which slots it should produce a block and gossip to the other block
producers. In turn, the block producer node should keep a copy of the block
tree and grow it as it receives valid blocks from other block producers. A
block producer prunes the tree in parallel using Algorithm
\ref{algo-block-tree-prunning}.

\subsection{Preliminaries}

\begin{definition}
  A {\tmstrong{block producer}}, noted by $\mathcal{P}_j$, is a node running
  Polkadot RE which is authorized to keep a transaction queue and which gets a
  turn in producing blocks.
\end{definition}

\begin{definition}
  {\tmstrong{Block authoring session key pair $(\tmop{sk}^s_j,
  \tmop{pk}^s_j)$}} is an SR25519 key pair which the block producer
  $\mathcal{P}_j$ signs by their account key (see Definition
  \ref{defn-account-key}) and is used to sign the produced block as well as to
  compute its lottery values in Algorithm \ref{algo-block-production-lottery}.
  
\end{definition}

\begin{definition}
  \label{defn-epoch-slot}A block production {\tmstrong{epoch}}, formally
  referred to as $\mathcal{E}$ is a period with pre-known starting time and
  fixed length during which the set of block producers stays constant. Epochs
  are indexed sequentially, and we refer to the $n^{\tmop{th}}$ epoch since
  genesis by $\mathcal{E}_n$. Each epoch is divided into equal length periods
  known as block production {\tmstrong{slots}}, sequentially indexed in each
  epoch. The index of each slot is called {\tmstrong{slot number}}. Each slot
  is awarded to a subset of block producers during which they are allowed to
  generate a block.
\end{definition}

\begin{notation}
  \label{note-slot}We refer to the number of slots in epoch $\mathcal{E}_n$ by
  $\tmop{sc}_n$. $\tmop{sc}_n$ is set to the \tmverbatim{duration} field in
  the returned data from the call of the Runtime entry
  \tmverbatim{BabeApi\_epoch} (see \ref{sect-rte-babeapi-epoch}) at the
  beginning of each epoch. For a given block $B$, we use the notation
  {\tmstrong{$s_B$}} to refer to the slot during which $B$ has been produced.
  Conversely, for slot $s$, $\mathcal{B}_s$ is the set of Blocks generated at
  slot $s$.
\end{notation}

Definition \ref{defn-epoch-subchain} provides an iterator over the blocks
produced during an specific epoch.

\begin{definition}
  \label{defn-epoch-subchain} By {\tmname{SubChain($\mathcal{E}_n$)}} for
  epoch $\mathcal{E}_n$, we refer to the path graph of $\tmop{BT}$ which
  contains all the blocks generated during the slots of epoch $\mathcal{E}_n$.
  When there is more than one block generated at a slot, we choose the one
  which is also on {\tmname{Longest-Chain($\tmop{BT}$)}}.
\end{definition}

\subsection{Block Production Lottery}

\begin{definition}
  \label{defn-winning-threshold}{\tmstrong{Winning threshold}} denoted by
  {\tmstrong{$\tau$}} is the threshold which is used alongside with the result
  of Algorirthm \ref{algo-block-production-lottery} to decide if a block
  producer is the winner of a specific slot. $\tau$ is set to result of call
  into {\code*{BabeApi\_slot\_winning\_threshold}} runtime entry.
\end{definition}

A block producer aiming to produce a block during $\mathcal{E}_n$ should run
Algorithm \ref{algo-block-production-lottery} to identify the slots it is
awarded. These are the slots during which the block producer is allowed to
build a block. The $\tmop{sk}$ is the block producer lottery secret key and
$n$ is the index of epoch for whose slots the block producer is running the
lottery.

\custombinding{7}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  7. }
  \label{algo-block-production-lottery}{\tmname{Block-production-lottery}}($\tmop{sk}
  :$session secret key of the producer,
  
  $n :$epoch index)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$r \leftarrow${\tmname{Epoch-Randomness$(n)$}}}}

{\state{{\FORTO{$i \assign 1$}{$\tmop{sc}_n$}}}}

{\state{$(d, \pi) \leftarrow${\tmem{{\tmname{VRF}}}}($r, i, \tmop{sk}$)}}

{\state{$A [i] \leftarrow (d, \pi)${\END}}}

{\state{{\RETURN{A}}}}}}

\hrulefill{\medskip}

For any slot $i$ in epoch $n$ where $d < \tau$, the block producer is required
to produce a block. For the definitions of {\tmname{Epoch-Randomness}} and
{\tmem{{\tmname{VRF}}}} functions, see Algorithm \ref{algo-epoch-randomness}
and Section \ref{sect-vrf} respectively.

\subsection{Slot Number Calculation}

It is essential for a block producer to calculate and validate the slot number
at a certain point in time. Slots are dividing the time continuum in an
overlapping interval. At a given time, the block producer should be able to
determine the set of slots which can be associated to a valid block generated
at that time. We formalize the notion of validity in the following
definitions:

\begin{definition}
  \label{slot-time-cal-tail}The {\tmstrong{slot tail}}, formally referred to
  by $\tmop{SlTl}$ represents the number of on-chain blocks that are used to
  estimate the slot time of a given slot. This number is set to be 1200.
\end{definition}

Algorithm \ref{algo-slot-time} determines the slot time for a future slot
based on the {\tmem{block arrival time}} associated with blocks in the slot
tail defined in Definition \ref{defn-block-time}.

\begin{definition}
  \label{defn-block-time}The {\tmstrong{block arrival time}} of block $B$ for
  node $j$ formally represented by {\tmstrong{$T^j_B$}} is the local time
  of\tmverbatim{} node $j$ when node $j$ has received the block $B$ for the
  first time. If the node $j$ itself is the producer of $B$, $T_B^j$ is set
  equal to the time that the block is produced. The index $j$ in $T^j_B$
  notation may be dropped and B's arrival time is referred to by $T_B$ when
  there is no ambiguity about the underlying node.
\end{definition}

In addition to the arrival time of block $B$, the block producer also needs to
know how many slots have passed since the arrival of $B$. This value is
formalized in Definition \ref{defn-slot-offset}.

\begin{definition}
  \label{defn-slot-offset}Let $s_i$ and $s_j$ be two slots belonging to epochs
  $\mathcal{E}_k$ and $\mathcal{E}_l$. By {\tmname{Slot-Offset}}$(s_i, s_j)$
  we refer to the function whose value is equal to the number of slots between
  $s_i$ and $s_j$ (counting $s_j$) on time continuum. As such, we have
  {\tmname{Slot-Offset}}$(s_i, s_i) = 0$.
\end{definition}

\custombinding{8}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  8. } \label{algo-slot-time}{\tmname{Slot-Time}}($s$:
  the slot number of the slot whose time needs to be determined)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$T_s \leftarrow \{ \}$}}

{\state{$B_d \leftarrow${\tmname{Deepest-Leaf($\tmop{BT}$)}}}}

{\state{{\FORIN{$B_i$}{{\tmname{SubChain}}($B_{H_n (B_d) - \tmop{SITL}}$,
$B_d$)}}}}

{\state{{\tmname{$s_t^{B_i} \leftarrow T^{}_{B_i}$+Slot-Offset($s_{B_i},
s$)$\times \mathcal{T}_{}$}}}}

{\state{$T_s \leftarrow T_s \cup s_t^{B_i}${\END}}}

{\state{{\RETURN{Median($T_s$)}}}}}}

\hrulefill{\medskip}

\subsection{Block Production}

At each epoch, each block producer should run Algorithm
\ref{algo-block-production} to produce blocks during the slots it has been
awarded during that epoch. The produced blocks need to be broadcasted
alongside with the {\tmem{babe header}} defined in Definition
\ref{defn-babe-header}.

\begin{definition}
  The \label{defn-babe-header}{\tmstrong{Babe Header}} of block B, referred to
  formally by {\tmstrong{$H_{\tmop{Babe}} (B)$}} is a tuple that consists of
  the following components:
  \[ (\pi, d, j, s, w) \]
  in which:
  
  \begin{center}
    \begin{tabular}{rl}
      $\pi, d$: & are the results of the block lottervrf\_output, vrfy for
      slot s. \\
      $j$: & is the SR25519 session public key associated with the block
      producer. \\
      s: & is the slot at which the block is produced.\\
      w & reserved
    \end{tabular}
  \end{center}
  
  \ 
\end{definition}

The block producer includes $H_{\tmop{Babe}} (B)$ as a log in $H_d (B)$ and
sign $\tmop{Head} (B)$ as defined in Definition \ref{defn-block-signature}

\begin{definition}
  \label{block-signature}The {\tmstrong{Block Signature}} noted by $S_B$ is
  computed as $\tmop{Sig}_{\tmop{SR} 25519, \tmop{sk}^s_j}
  (\tmop{Enc}_{\tmop{SC}} (\tmop{Black} 2 s (\tmop{Head} (B_{}))))$
\end{definition}

\

\custombinding{9}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  9. }
  \label{algo-block-production}\tmverbatim{}{\tmname{Invoke-Block-Authoring}}($\tmop{sk}$,
  pk, $n$, $\tmop{BT} : \tmop{Current} \tmop{Block} \tmop{Tree}$)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$A
\leftarrow${\tmname{Block-production-lottery($\tmop{sk}$, $n$)}}}}

{\state{{\FORTO{$s \leftarrow 1$}{$\tmop{sc}_n$}}}}

{\state{{\tmname{Wait}}({\tmstrong{until}} {\tmname{Slot-Time}}(s))}}

{\state{$(d, \pi) \leftarrow A [s]$}}

{\state{{\IF{$d < \tau$}}}}

{\state{$C_{\tmop{Best}} \leftarrow${\tmname{Longest-Chain}}(BT)}}

{\state{{\tmname{$B_s \leftarrow$Build-Block($C_{\tmop{Best}}$)}}}}

{\state{{\tmname{Broadcast-Block}}($B_s, H_{\tmop{Babe}} (B_s)$)}}}}

\hrulefill{\medskip}

\subsection{Epoch Randomness}\label{sect-epoch-randomness}

At the end of epoch $\mathcal{E}_n$, each block producer is able to compute
the randomness seed it needs in order to participate in the block production
lottery in epoch $\mathcal{E}_{n + 2}$. The computation of the seed is
described in Algorithm \ref{algo-epoch-randomness} which uses the concept of
epoch subchain described in Definition \ref{defn-epoch-subchain}.

\custombinding{10}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  10. }
  \label{algo-epoch-randomness}{\tmname{Epoch-Randomness}}($n > 2 :$epoch
  index)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$\rho \leftarrow \phi$}}

{\state{{\FORIN{$B$}{}}{\tmem{{\tmname{SubChain($\mathcal{E}_{n - 2}$)}}}}}}

{\state{$\rho \leftarrow \rho | | d_B${\END}}}

{\state{{\RETURN{Blake2b({\tmname{Epoch-Randomness}}($n -
1$)\textbar\textbar$n$\textbar\textbar$\rho$)}}}}}}

\hrulefill{\medskip}

In which value $d_B$ is the VRF output computed for slot $s_B$ by running
Algorithm \ref{algo-block-production-lottery}.

\

\subsection{Verifying Authorship Right}

\begin{definition}
  Seal $D_s$ {\todo{define seal}}
\end{definition}

When a Polkadot node receives a produced block, it needs to verify if the
block producer was entitled to produce the block in the given slot by running
Algorithm \ref{algo-verify-authorship-right} where:
\begin{itemizeminus}
  \item T$_B$ is $B$'s arrival time defined in Definition
  \ref{defn-block-time}.
  
  \item $H_d (B)$ is the digest sub-component of $\tmop{Head} (B)$ defined in
  Definition \ref{defn-block-header}.
  
  \item $\tmop{AuthorityDirectory}^{\mathcal{E}_c}$ is the set of Authority ID
  for block producers of epoch $\mathcal{E}_c$.
  
  \item {\tmname{verify-Slot-Winner}} is defined in Algorithm
  \ref{algo-verify-slot-winner}.
\end{itemizeminus}
\custombinding{11}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  11. }
  \label{algo-verify-authorship-right}{\tmname{Verify-Authorship-Right}}($\tmop{Head}_s
  (B)$: The header of the block being verified) \\
  \hline
\end{tabular}

{\algorithmic{{\state{$s
\leftarrow${\tmname{Slot-Number-At-Given-Time}}($T_{B_{}}$)}}

{\state{$\mathcal{E}_c \leftarrow${\tmname{Current-Epoch}}()}}

{\state{$(D_1, \ldots, D_{\tmop{length} (H_d (B))}) \leftarrow H_d (B)$}}

{\state{$D_s \leftarrow D_{\tmop{length} (H_d (B))}$}}

{\state{$H_d (B) \leftarrow (D_1, \ldots, D_{\tmop{length} (H_d (B)) - 1})$
//remove the seal from the digest}}

{\state{($\tmop{id}, \tmop{Sig}_B$)$\leftarrow \tmop{Dec}_{\tmop{SC}} (D_s)$}}

{\state{{\IF{$\tmop{id} \neq${\tmname{Seal-Id}}}}}}

{\state{{\ERROR{``Seal missing''{\END}}}}}

{\state{AuthorID $\leftarrow \tmop{AuthorityDirectory}^{\mathcal{E}_c}
[H_{\tmop{BABE}} (B) . \tmop{SingerIndex}]$}}

{\state{{\tmname{Verify-Signature}}($\tmop{AuthorID}, H_h (B),
\tmop{Sig}_B$)}}

{\state{{\IF{$\exists B' \in \tmop{BT} : H_h (B) \neq H_h (B)$
{\tmstrong{and}} $s_B = s'_B$ {\tmstrong{and}} $\tmop{SignerIndex}_B =
\tmop{SignerIndex}_{B'}$}}}}

{\state{{\ERROR{``Block producer is equivocating''{\END}}}}}

{\state{{\tmname{Verify-Slot-Winner}}($(d_B, \pi_B), s$,AuthorID)}}}}

\hrulefill{\medskip}

Algorithm \ref{algo-verify-slot-winner} is run as a part of the verification
process, when a node is importing a block, in which:
\begin{itemizeminus}
  \item {\tmname{Epoch-Randomness}} is defined in Algorithm
  \ref{algo-epoch-randomness}.
  
  \item $H_{\tmop{BABE}} (B)$ is the BABE header defined in Definition
  \ref{defn-babe-header}.
  
  \item {\tmname{Verify-VRF}} is described in Section \ref{sect-vrf}.
  
  \item $\tau$ is the winning threshold defined in
  \ref{defn-winning-threshold}.
\end{itemizeminus}
\custombinding{12}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  12. }
  \label{algo-verify-slot-winner}{\tmname{Verify-Slot-Winner}}($B$: the block
  whose winning status to be verified)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$\mathcal{E}_c \leftarrow${\tmname{Current-Epoch}}}}

{\state{$\rho \leftarrow${\tmname{Epoch-Randomness}}$(c)$}}

{\state{{\tmname{Verify-VRF}}($\rho, H_{\tmop{BABE}} (B) . (d_B, \pi_B),
H_{\tmop{BABE}} (B) .s, c$)}}

{\state{{\IF{$d_B \geqslant \tau$}}}}

{\state{{\ERROR{``Block producer is not a winner of the slot''{\END}}}}}}}

\hrulefill{\medskip}

$(d_B, \pi_B)$: Block Lottery Result for Block $B$,

$s_n$: the slot number,

$n$: Epoch index

AuthorID: The public session key of the block producer

\subsection{Blocks Building Process}

The blocks building process is triggered by Algorithm
\ref{algo-block-production} of the consensus engine which runs Alogrithm
\ref{algo-build-block}.

\custombinding{13}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  13. }
  \label{algo-build-block}{\tmname{Build-Block}}($C_{\tmop{Best}}$: The chain
  where at its head, the block to be constructed,
  
  s: Slot number)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$P_B \leftarrow_{}${\tmname{Head($C_{\tmop{Best}}$)}}}}

{\state{$H_h (P_B) \leftarrow${\tmname{Call-Runtime-Entry}}$\left(
\text{\tmverbatim{block\_hash\_from\_id}}, H_i (P_B) \right)$}}

{\state{$\tmop{Head} (B) \leftarrow$($H_p \leftarrow H_h (P_B), H_i \leftarrow
H_i (P_B) + 1, H_r \leftarrow \phi, H_e \leftarrow \phi, H_d \leftarrow
\phi$)}}

{\state{{\tmname{Call-Runtime-Entry}}$\left(
\text{\tmverbatim{initialze\_block}}, \tmop{Head} (_{} B) \right)$}}

{\state{{\tmname{Call-Runtime-Entry}}$\left(
\text{\tmverbatim{inherent\_extrinsics}},
\text{{\tmname{Block-Inherents-Data}}} \right)${\END}}}

{\state{{\FORIN{$E$}{{\tmname{Inherents-Queue}}}}}}

{\state{{\tmname{$R \leftarrow$Call-Runtime-Entry}}$\left(
\text{\tmverbatim{apply\_extrinsic}}, E \right)${\END}}}

{\state{{\WHILE{{\tmstrong{not }}{\tmname{Block-Is-Full($R$}})
{\tmstrong{and}} {\tmstrong{not}} {\tmname{End-Of-Slot(s)}}}}}}

{\state{$E
\leftarrow$\tmverbatim{}{\tmname{{\tmname{}}Next-Ready-Extrinsic()}}}}

{\state{$R \leftarrow${\tmname{Call-Runtime-Entry}}$\left(
\text{\tmverbatim{apply\_extrinsics}}, E \right)$}}

{\state{{\IF{{\tmstrong{not}} {\tmname{Block-Is-FULL($R$}})}}}}

{\state{{\tmname{Drop(Ready-Extrinsic-Queue,$E$)}}{\END}{\END}}}

{\state{$\tmop{Head} (B) \leftarrow${\tmname{Call-Runtime-Entry}}$\left(
\text{\tmverbatim{finalize\_block}}, E \right)${\END}}}}}

\hrulefill{\medskip}

$\tmop{Head} (B)$ is defined in Definition \ref{defn-block-header}.
{\tmname{Block-Inherents-Data}}, {\tmname{Inherents-Queue}},
{\tmname{Block-Is-Full}} and {\tmname{Next-Ready-Extrinsic}} are defined in
Definition {\todo{Define these entities}}

\section{Finality}\label{sect-finality}\label{sect-grandpa}

Polkadot RE uses GRANDPA Finality protocol
{\cite{alistair_stewart_grandpa:_2019}} to finalize blocks. Finality is
obtained by consecutive rounds of voting by validator nodes. Validators
execute GRANDPA finality process in parallel to Block Production as an
independent service. In this section, we describe the different functions that
GRANDPA service is supposed to perform to successfully participate in the
block finalization process.

\subsection{Preliminaries}

\begin{definition}
  A {\tmstrong{GRANDPA Voter}}, $v$, is represented by a key pair
  $(k^{\tmop{pr}}_v, v_{\tmop{id}})$ where $k_v^{\tmop{pr}}$ represents its
  private key which is an $\tmop{ED} 25519$ private key, is a node running
  GRANDPA protocol, and broadcasts votes to finalize blocks in a Polkadot RE -
  based chain. The {\tmstrong{set of all GRANDPA voters}} is indicated by
  $\mathbb{V}$. For a given block B, we have
  \[ \mathbb{V}_B = \text{\tmverbatim{grandpa\_authorities}} (B) \]
  where $\mathtt{grandpa\_authorities}$ is the entry into runtime described in
  Section \ref{sect-rte-grandpa-auth}.
\end{definition}

\begin{definition}
  {\tmstrong{GRANDPA state}}, $\tmop{GS}$, is defined as
  \[ \tmop{GS} \assign \{\mathbb{V}, \tmop{id}_{\mathbb{V}}, r\} \]
  where:
  
  $\mathbb{V}$: is the set of voters.
  
  {\tmstrong{$\mathbb{V}_{\tmop{id}}$}}: is an incremental counter tracking
  \tmverbatim{}membership, which changes in V.
  
  {\tmstrong{r}}: is the votin\tmverbatim{}g round number.
\end{definition}

Now we need to define how Polkadot RE counts the number of votes for block
$B$. First a vote is defined as:

\begin{definition}
  \label{defn-vote}A {\tmstrong{GRANDPA vote }}or simply a vote for block $B$
  is an ordered pair defined as
  \[ V_{\nosymbol} (B) \assign (H_h (B), H_i (B)) \]
  where $H_h (B)$ and $H_i (B)$ are the block hash and the block number
  defined in Definitions \ref{defn-block-header} and
  \ref{defn-block-header-hash} respectively.
\end{definition}

\begin{definition}
  Voters engage in a maximum of two sub-rounds of voting for each round $r$.
  The first sub-round is called {\tmstrong{pre-vote}} and\tmverbatim{} the
  second sub-round is called {\tmstrong{pre-commit}}.
  
  By {\tmstrong{$V_v^{r, \tmop{pv}}$}} and {\tmstrong{$V_v^{r, \tmop{pc}}$}}
  we refer to the vote cast by voter $v$ in round $r$ (for block $B$) during
  the pre-vote and the pre-commit sub-round respectively.
\end{definition}

The GRANDPA protocol dictates how an honest voter should vote in each
sub-round, which is described in Algorithm \ref{alg-grandpa-round}. After
defining what constitues a vote in GRANDPA, we define how GRANDPA counts
votes.

\begin{definition}
  Voter $v$ {\tmstrong{equivocates}} if they broadcast two or more valid votes
  to blocks not residing on the same branch of the block tree during one
  voting sub-round. In such a situation, we say that $v$ is an
  {\tmstrong{equivocator}} and any vote $V_v^{r, \tmop{stage}} (B)$ cast by
  $v$ in that round is an {\tmstrong{equivocatory vote}} and
  \[ \mathcal{E}^{r, \tmop{stage}} \]
  represents the set of all equivocators voters in sub-round
  ``$\tmop{stage}$'' of round $r$. When we want to refer to the number
  of\tmverbatim{} equivocators whose equivocation has been observed by voter
  $v$ we refer to it by:
  \[ \mathcal{E}^{r, \tmop{stage}}_{\tmop{obs} (v)} \]
  
\end{definition}

\begin{definition}
  A vote $V_v^{r, \tmop{stage}} = V (B)$ is {\tmstrong{invalid}} if
  \begin{itemize}
    \begin{itemizedot}
      \item $H (B)$ does not correspond to a valid block;
      
      \item $B$ is not an (eventual) descendant of a previously finalized
      block;
      
      \item $M^{r, \tmop{stage}}_v$ does not bear a valid signature;
      
      \item $\tmop{id}_{\mathbb{V}}$ does not match the current $\mathbb{V}$;
      
      \item If $V_v^{r, \tmop{stage}}$ is an equivocatory vote.
    \end{itemizedot}
  \end{itemize}
\end{definition}

\begin{definition}
  For validator v, {\tmstrong{the set of observed direct votes for Block $B$
  in round $r$}}, formally denoted by $\tmop{VD}^{r, \tmop{stage}}_{\tmop{obs}
  (v)}^{\nosymbol}_{\nosymbol} (B)$ is equal to the union of:
  \begin{itemizedot}
    \item set of valid votes $V^{r, \tmop{stage}}_{v_i}$ cast in round $r$ and
    received by v such that $V^{r, \tmop{stage}}_{v_i} = V (B)$.
  \end{itemizedot}
\end{definition}

\begin{definition}
  We refer to {\tmstrong{the set of total votes observed by voter $v$ in
  sub-round ``$\tmop{stage}$'' of round $r$}} by {\tmstrong{$V^{r,
  \tmop{stage}}_{\tmop{obs} (v)}^{\nosymbol}_{\nosymbol}$}}.
  
  The {\tmstrong{set of all observed votes by $v$ in the sub-round stage of
  round $r$ for block $B$}}, {\tmstrong{$V^{r, \tmop{stage}}_{\tmop{obs} (v)}
  (B)$}} is equal to all of the observed direct votes casted for block $B$ and
  all of the $B$'s descendents defined formally as:
  \[ V^{r, \tmop{stage}}_{\tmop{obs} (v)} (B) \assign \bigcup_{v_i \in
     \mathbb{V}, B \geqslant B'} \tmop{VD}^{r, \tmop{stage}}_{\tmop{obs} (v)}
     (B')_{\nosymbol}^{\nosymbol}_{\nosymbol} \]
  The {\tmstrong{total number of observed votes for Block $B$ in round $r$}}
  is defined to be the size of that set plus the total number of equivocators
  voters:
  \[ \#V^{r, \tmop{stage}}_{\tmop{obs} (v)} (B) = |V^{r,
     \tmop{stage}}_{\tmop{obs} (v)} (B) | + | \mathcal{E}^{r,
     \tmop{stage}}_{\tmop{obs} (v)} | \]
\end{definition}

\begin{definition}
  The current {\tmstrong{pre-voted}} block $B^{r, \tmop{pv}}_v$ is the block
  with
  \[ H_n (B^{r, \tmop{pv}}_v) = \tmop{Max} (H_n (B) | \forall B :
     \#V_{\tmop{obs} (v)}^{r, \tmop{pv}} (B) \geqslant 2 / 3|\mathbb{V}|) \]
\end{definition}

Note that for genesis block $\tmop{Genesis}$ we always have $\#V_{\tmop{obs}
(v)}^{r, \tmop{pv}} (B) = | \mathbb{V} |$.

\

Finally, we define when a voter $v$ see a round as completable, that is when
they are confident that $B_v^{r, \tmop{pv}}$ is an upper bound for what is
going to be finalised in this round. \

\begin{definition}
  \label{defn-grandpa-completable}We say that round $r$ is
  {\tmstrong{completable}} if $|V^{r, \tmop{pc}}_{\tmop{obs} (v)} |
  +\mathcal{E}^{r, \tmop{pc}}_{\tmop{obs} (v)} > \frac{2}{3} \mathbb{V}$ and
  for all $B' > B_v^{r, \tmop{pv}}$:
  \[ \begin{array}{l}
       |V^{r, \tmop{pc}}_{\tmop{obs} (v)} | -\mathcal{E}^{r,
       \tmop{pc}}_{\tmop{obs} (v)} - |V^{r, \tmop{pc}}_{\tmop{obs}
       (v)_{\nosymbol}} (B') | > \frac{2}{3} |\mathbb{V}|
     \end{array} \]
\end{definition}

Note that in practice we only need to check the inequality for those $B' >
B_v^{r, \tmop{pv}}$ where $|V^{r, \tmop{pc}}_{\tmop{obs} (v)_{\nosymbol}} (B')
| > 0$.

\

\subsection{Voting Messages Specification}

Voting is done by means of broadcasting voting messages to the network.
Validators inform their peers about the block finalized in round $r$ by
broadcasting a finalization message (see Algorithm \ref{alg-grandpa-round} for
more details). These messages are specified in this section.

\begin{definition}
  A vote casted by voter $v$ should be broadcasted as a {\tmstrong{message
  $M^{r, \tmop{stage}}_v$}} to the network by voter $v$ with the following
  structure:
  \[ M^{r, \tmop{stage}}_v \assign \tmop{Enc}_{\tmop{SC}} (r,
     \tmop{id}_{\mathbb{V}}, \tmop{Enc}_{\tmop{SC}} (\tmop{stage}, V_v^{r,
     \tmop{stage}}, \tmop{Sig}_{\tmop{ED} 25519} (\tmop{Enc}_{\tmop{SC}}
     (\tmop{stage}, V_v^{r, \tmop{stage}}, r, V_{\tmop{id}}), v_{\tmop{id}})
  \]
  Where:
  {\center{\begin{tabular}{rll}
    r: & round number & 64 bit integer\\
    $V_{\tmop{id}}$: & incremental change tracker counter & 64 bit integer\\
    {\rightaligned{$v_{\tmop{id}}$}}: & Ed25519 public key of $v$ & 32 byte
    array\\
    {\rightaligned{}}$\tmop{stage}$: & 0 if it is the pre-vote sub-round & 1
    byte\\
    & 1 if it the pre-commit sub-round & 
  \end{tabular}}}
  
\end{definition}

\begin{definition}
  \label{defn-grandpa-justification}The {\tmstrong{justification for block B
  in round $r$}} of GRANDPA protocol defined $J^r (B)$ is a vector of pairs of
  the type:
  \[ (V (B'), (\tmop{Sign}^{r, \tmop{pc}}_{v_i} (B'), v_{\tmop{id}})) \]
  in which either
  \[ B' \geqslant B \]
  or $V^{r, \tmop{pc}}_{v_i} (B')$ is an equivocatory vote.
  
  In all cases, $\tmop{Sign}^{r, \tmop{pc}}_{v_i} (B')$ is the signature of
  voter $v_i$ broadcasted during the pre-commit sub-round of round r.
  
  We say $J^r (B)$ {\tmstrong{justifies the finalization}} of $B$ if the
  number of valid signatures in $J^r (B)$ is greater than $\frac{2}{3}
  |\mathbb{V}_B |$.
\end{definition}

\begin{definition}
  {\tmstrong{$\tmop{GRANDPA}$ finalizing message for block $B$ in round $r$}}
  represented as {\tmstrong{$M_v^{r, \tmop{Fin}}$(B)}} is a message
  broadcasted by voter $v$ to the network indicating that voter $v$ has
  finalized block $B$ in round $r$. It has the following structure:
  \[ M^{r, \tmop{Fin}}_v (B) \assign \tmop{Enc}_{\tmop{SC}} (r, V (B), J^r
     (B)) \]
  in which $J^r (B)$ in the justification defined in Definition
  \ref{defn-grandpa-justification}.
\end{definition}

\subsection{Initiating the GRANDPA State}

A validator needs to initiate its state and sync it with other validators, to
be able to participate coherently in the voting process. In particular,
considering that voting is happening in different rounds and each round of
voting is assigned a unique sequential round number $r_v$, it needs to
determine and set its round counter $r$ in accordance with the current voting
round $r_n$, which is currently undergoing in the network.

As instructed in Algorithm \ref{alg-join-leave-grandpa}, whenever the
membership of GRANDPA voters changes, $r$ is set to 0 and $V_{\tmop{id}}$
needs to be incremented.

\custombinding{14}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  14. }
  \label{alg-join-leave-grandpa}{\tmname{Join-Leave-Grandpa-Voters}}
  ($\mathcal{V}$)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$r \leftarrow 0$}}

{\state{$\mathcal{V}_{\tmop{id}} \leftarrow \tmop{ReadState} ('
\tmop{AUTHORITY} \_ \tmop{SET} \_ \tmop{KEY}')$}}

{\state{$\mathcal{V}_{\tmop{id}} \leftarrow \mathcal{V}_{\tmop{id}} + 1$}}

{\state{{\tmname{Execute-One-Grandpa-Round}}$(r)$}}}}

\hrulefill{\medskip}

\subsection{Voting Process in Round $r$}

For each round $r$, an honest voter $v$ must participate in the voting process
by following Algorithm \ref{algo-grandpa-round}.

\custombinding{15}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  15. }
  \label{algo-grandpa-round}{\tmname{Play-Grandpa-round}}$(r)$\\
  \hline
\end{tabular}

{\algorithmic{{\state{$t_{r, v} \leftarrow$Time}}

{\state{$\tmop{primary} \leftarrow${\tmname{Derive-Primary}}}}

{\state{{\IF{$v = \tmop{primary}$}}}}

{\state{{\tmname{Broadcast(}}\left.$M_{v_{\nosymbol}}^{r - 1,
\tmop{Fin}}$({\tmname{Best-Final-Candidate}}($r$-1))\right){\END}}}

{\state{{\tmname{Receive-Messages}}({\tmstrong{until}} Time $\geqslant t_{r_,
v} + 2 \times T$ {\tmstrong{or}} $r$ {\tmstrong{is}} completable){\END}}}

{\state{$L \leftarrow${\tmname{Best-Final-Candidate}}($r$-1)}}

{\state{{\IF{{\tmname{Received($M_{v_{\tmop{primary}}}^{r, \tmop{pv}} (B)$)}}
{\tmstrong{and}} $B^{r, \tmop{pv}}_v \geqslant B > L$}}}}

{\state{$N \leftarrow B${\END}}}

{\state{{\ELSE{\ }}}}

{\state{$N \leftarrow B' : H_n (B') = \max \{H_n (B') : B' > L\} \END$}}

{\state{{\tmname{Broadcast}}($M_v^{r, \tmop{pv}} (N)$)}}

{\state{{\tmname{Receive-Messages}}({\tmstrong{until}} $B^{r,
\tmop{pv}_{\nosymbol}}_v \geqslant L$ {\tmstrong{and}} (Time $\geqslant t_{r_,
v} + 4 \times T${\tmstrong{ or }}$r$ {\tmstrong{is}} completable))}}

{\state{{\tmname{Broadcast($M_v^{r, \tmop{pc}}$($B_v^{r, \tmop{pv}}$))}}}}

{\state{{\tmname{Attempt-To-Finalize-Round}}($r$)}}

{\state{{\tmname{Receive-Messages}}({\tmstrong{until}} $r$ {\tmstrong{is}}
completable)}}

{\state{{\tmname{Play-Grandpa-round}}($r + 1$)}}}}

\hrulefill{\medskip}

The condition of {\tmem{completablitiy}} is defined in Definition
\ref{defn-grandpa-completable}. {\tmname{Best-Final-Candidate}} function is
explained in Algorithm \ref{algo-grandpa-best-candidate} and
{\tmname{{\tmname{Attempt-To-Finalize-Round}}($r$)}} is described in Algorithm
\ref{algo-attempt-tofinalize}.

\custombinding{16}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  16. }
  \label{algo-grandpa-best-candidate}{\tmname{Best-Final-Candidate}}($r$)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$\mathcal{C}_{\nosymbol} \leftarrow \{B' |B' \leqslant
B_v^{r, \tmop{pv}} : |V_v^{r, \tmop{pc}} | -\#V_v^{r, \tmop{pc}} (B')
\leqslant 1 / 3|\mathbb{V}|\}$}}

{\state{{\IF{$\mathcal{C}= \phi$}}}}

{\state{{\RETURN{$\phi${\END}}}}}

{\state{{\ELSE{\ }}}}

{\state{{\RETURN{$E \in \mathcal{C}: H_n (E) = \max \{H_n (B') : B' \in
\mathcal{C}\}${\END}}}}}}}

\hrulefill{\medskip}

\custombinding{17}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextsc{Algorithm  17. }
  \label{algo-attempt-tofinalize}{\tmname{Attempt-To-Finalize-Round}}($r$)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$L \leftarrow${\tmname{Last-Finalized-Block}}}}

{\state{$E \leftarrow${\tmname{Best-Final-Candidate}}($r$)}}

{\state{{\IF{$E \geqslant L$ {\tmstrong{and}} $V^{r, \tmop{pc}}_{\tmop{obs}
(v)}^{\nosymbol}_{\nosymbol} (E) > 2 / 3 |\mathbb{V}|$}}}}

{\state{{\tmname{Last-Finalized-Block}}$\leftarrow E$}}

{\state{{\IF{$M_v^{r, \tmop{Fin}} (E) \nin${\tmname{Received-Messages}}}}}}

{\state{{\tmname{Broadcast}}($M_v^{r, \tmop{Fin}} (E)$)}}

{\state{{\RETURN{{\END}{\END}}}}}

{\state{{\tmstrong{schedule-call}} {\tmname{Attempt-To-Finalize-Round}}($r$)
{\tmstrong{when}} {\tmname{Receive-Messages}} }}}}

\hrulefill{\medskip}

\section{Block Finalization}\label{sect-block-finalization}

\begin{definition}
  \label{defn-finalized-block}A Polkadot relay chain node n should consider
  block $B$ as {\tmstrong{finalized}} if any of the following criteria holds
  for $B' \geqslant B$:
  \begin{itemize}
    \item $V^{r, \tmop{pc}}_{\tmop{obs} (n)}^{\nosymbol}_{\nosymbol} (B') > 2
    / 3 |\mathbb{V}_{B'} |$.
    
    \item it receives a $M_v^{r, \tmop{Fin}} (B')$ message in which $J^r (B)$
    justifies the finalization (according to Definition
    \ref{defn-grandpa-justification}).
    
    \item it receives a block data message for $B'$ with $\tmop{Just} (B')$
    defined in Section \ref{sect-justified-block-header} which justifies the
    finalization. 
  \end{itemize}
\end{definition}

for
\begin{itemizedot}
  \item any round $r$ if the node $n$ is {\tmem{not}} a GRANDPA voter.
  
  \item only for rounds $r$ for which the the node $n$ has invoked Algorithm
  \ref{algo-grandpa-round} if $n$ is a GRANDPA voter.
\end{itemizedot}
Note that all Polkadot relay chain nodes are supposed to listen to GRANDPA
finalizing messages regardless if they are GRANDPA
voters.\appendix\chapter{Cryptographic Algorithms}

\section{Hash Functions}\label{sect-hash-functions}

\section{BLAKE2}\label{sect-blake2}

BLAKE2 is a collection of cryptographic hash functions known for their high
speed. their design closely resembles BLAKE which has been a finalist in SHA-3
competition.

Polkadot is using Blake2b variant which is optimized for 64bit platforms.
Unless otherwise specified, Blake2b hash function with 256bit output is used
whenever Blake2b is invoked in this document. The detailed specification and
sample implementations of all variants of Blake2 hash functions can be found
in RFC 7693 {\cite{saarinen_blake2_2015}}.

\section{Randomness}\label{sect-randomness}

\section{VRF}\label{sect-vrf}

\chapter{Auxiliary Encodings}\label{sect-encoding}

\section{SCALE Codec}\label{sect-scale-codec}

Polkadot RE uses {\tmem{Simple Concatenated Aggregate Little-Endian'' (SCALE)
codec}} to encode byte arrays as well as other data structures. SCALE provides
a canonical encoding to produce consistent hash values across their
implementation, including the Merkle hash proof for the State Storage.

\begin{definition}
  \label{defn-scale-byte-array}The {\tmstrong{SCALE codec}} for
  {\tmstrong{Byte array}} $A$ such that
  \[ A \assign b_1 b_2 \ldots b_n \]
  such that $n < 2^{536}$ is a byte array refered to $\tmop{Enc}_{\tmop{SC}}
  (A)$ and defined as:
  \[ \tmop{Enc}_{\tmop{SC}} (A) \assign \tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}
     (\| A \|) | | A \]
  where $\tmop{Enc}_{\tmop{SC}}^{\tmop{Len}}$ is defined in Definition
  \ref{defn-sc-len-encoding}. 
\end{definition}

\begin{definition}
  \label{defn-scale-tuple}The {\tmstrong{SCALE codec}} for {\tmstrong{Tuple}}
  $T$ such that:
  \[ T \assign (A_1, \ldots, A_n) \]
  Where $A_i$'s are values of {\tmstrong{different types}}, is defined as:
  \[ \tmop{Enc}_{\tmop{SC}} (T) \assign \tmop{Enc}_{\tmop{SC}} (A_1) | |
     \tmop{Enc}_{\tmop{SC}} (A_2) | | \ldots | | \tmop{Enc}_{\tmop{SC}} (A_n)
  \]
\end{definition}

In case of a tuple (or struct), the knowledge of the shape of data is not
encoded even though it is necessary for decoding. The decoder needs to derive
that information from the context where the encoding/decoding is happenning.

\begin{definition}
  \label{defn-varrying-data-type}We define a {\tmstrong{varying data}} type to
  be an ordered set of data types
  \[ \mathcal{T}= \{ T_1, \ldots, T_n \} \]
  A value $\tmmathbf{A}$ of varying date type is a pair $(A_{\tmop{Type}},
  A_{\tmop{Value}})$ where $A_{\tmop{Type}} = T_i$ for some $T_i \in
  \mathcal{T}$ and $A_{\tmop{Value}}$ is its value of type $T_i$. We define
  $\tmop{idx} (T_i) = i - 1.$
  
  In particular, we define {\tmstrong{optional type}} to be $\mathcal{O}= \{
  \tmop{None}, T_2 \}$ for some data type $T_2$ where $\tmop{idx}
  (\tmop{None}) = 0$ $(\tmop{None}, \phi)$ is the only possible value, when
  the data is of type None and a codec value is one byte of 0 value.
  
  
\end{definition}

\begin{definition}
  \label{defn-scale-variable-type}Scale coded for value {\tmstrong{$A =
  (A_{\tmop{Type}}, A_{\tmop{Value}})$ of varying data type}} $\mathcal{T}= \{
  T_1, \ldots, T_n \}$
  \[ \tmop{Enc}_{\tmop{SC}} (A) \assign \tmop{Enc}_{\tmop{SC}} (\tmop{Idx}
     (A_{\tmop{Type}})) | | \tmop{Enc}_{\tmop{SC}} (A_{\tmop{Value}}) \]
  Where $\tmop{Idx}$ is encoded in a fixed length integer determining the type
  of $A$.
  
  In particular, for the optional type defined in Definition
  \ref{defn-varrying-data-type}, we have:
  \[ \tmop{Enc}_{\tmop{SC}} ((\tmop{None}, \phi)) \assign 0_{\mathbb{B}_1} \]
\end{definition}

SCALE codec does not encode the correspondence between the value of
$\tmop{Idx}$ defined in Definition \ref{defn-scale-variable-type} and the data
type it represents; the decoder needs prior knowledge of such correspondence
to decode the data.

\begin{definition}
  \label{defn-scale-list}The {\tmstrong{SCALE codec}} for
  {\tmstrong{sequence}} $S$ such that:
  \[ S \assign A_1, \ldots, A_n \]
  where $A_i$'s are values of {\tmstrong{the same type}} (and the decoder is
  unable to infer value of $n$ from the context) is defined as:
  \[ \tmop{Enc}_{\tmop{SC}} (S) \assign \tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}
     (\| S \|) \tmop{Enc}_{\tmop{SC}} (A_1) | \tmop{Enc}_{\tmop{SC}} (A_2) |
     \ldots | \tmop{Enc}_{\tmop{SC}} (A_n) \]
  where $\tmop{Enc}_{\tmop{SC}}^{\tmop{Len}}$ is defined in Definition
  \ref{defn-sc-len-encoding}. SCALE codec for {\tmstrong{dictionary}} or
  {\tmstrong{hashtable}} D with key-value pairs $(k_i, v_i)$s such that:
  \[ D \assign \{ (k_1, v_1), \ldots, (k_1, v_n) \} \]
  is defined the SCALE codec of $D$ as a sequence of key value pairs (as
  tuples):
  \[ \tmop{Enc}_{\tmop{SC}} (D) \assign \tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}
     (\| D \|) \tmop{Enc}_{\tmop{SC}} ((k_1, v_1)_{}) | \tmop{Enc}_{\tmop{SC}}
     ((k_2, v_2)) | \ldots | \tmop{Enc}_{\tmop{SC}} ((k_n, v_n)) \]
  \[ \  \]
\end{definition}

\begin{definition}
  The {\tmstrong{SCALE codec}} for {\tmstrong{boolean value}} $b$ defined as a
  byte as follows:
  \[ \begin{array}{ll}
       \tmop{Enc}_{\tmop{SC}} : & \{ \tmop{False}, \tmop{True} \} \rightarrow
       \mathbb{B}_1\\
       & b \rightarrow \left\{ \begin{array}{lcl}
         0 &  & b = \tmop{False}\\
         1 &  & b = \tmop{True}
       \end{array} \right.
     \end{array} \]
\end{definition}

\begin{definition}
  The {\tmstrong{SCALE codec, $\tmop{Enc}_{\tmop{SC}}$}} for other types such
  as fixed length integers not defined here otherwise, is equal to little
  endian encoding of those values defined in Definition
  \ref{defn-little-endian}. 
\end{definition}

\subsection{Length Encoding}\label{sect-int-encoding}

{\tmem{SCALE Length encoding}} is used to encode integer numbers of variying
sizes prominently in an encoding length of arrays:

\begin{definition}
  \label{defn-sc-len-encoding}{\tmstrong{SCALE Length Encoding,
  $\tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}$}} also known as compact encoding of a
  non-negative integer number $n$ is defined as follows:
  \[ \begin{array}{ll}
       \tmop{Enc}^{\tmop{Len}}_{\tmop{SC}} : & \mathbb{N} \rightarrow
       \mathbb{B}\\
       & n \rightarrow b \assign \left\{ \begin{array}{lll}
         l^{\nosymbol}_1 &  & 0 \leqslant n < 2^6\\
         i^{\nosymbol}_1 i^{\nosymbol}_2 &  & 2^6 \leqslant n < 2^{14}\\
         j^{\nosymbol}_1 j^{\nosymbol}_2 j_3 &  & 2^{14} \leqslant n <
         2^{30}\\
         k_1^{\nosymbol} k_2^{\nosymbol} \ldots k_m^{\nosymbol}  &  & 2^{30}
         \leqslant n
       \end{array} \right.
     \end{array} \]
  in where the least significant bits of the first byte of byte array b are
  defined as follows:
  \[ \begin{array}{lcc}
       l^1_1 l_1^0 & = & 00\\
       i^1_1 i_1^0 & = & 01\\
       j^1_1 j_1^0 & = & 10\\
       k^1_1 k_1^0 & = & 11
     \end{array} \]
  and the rest of the bits of $b$ store the value of $n$ in little-endian
  format in base-2 as follows:
  \[ \left. \begin{array}{lll}
       l^7_1 \ldots l^3_1 l^2_1 &  & n < 2^6\\
       i_2^7 \ldots i_2^0 i_1^7 \ldots i^2_1^{\nosymbol} &  & 2^6 \leqslant n
       < 2^{14}\\
       j_4^7 \ldots j_4^0 j_3^7 \ldots j_1^7 \ldots j^2_1 &  & 2^{14}
       \leqslant n < 2^{30}\\
       k_2 + k_3 2^8 + k_4 2^{2 \cdummy 8} + \cdots + k_m 2^{(m - 2) 8} &  &
       2^{30} \leqslant n
     \end{array} \right\} \assign n \]
  such that:
  \[ k^7_1 \ldots k^3_1 k^2_1 : = m - 4 \]
\end{definition}

\section{Frequently SCALEd Object}

In this section, we will specify the objects which are frequently used in
transmitting data between PDRE, \ Runtime and other clients and their SCALE
encodings.

\subsection{Result}

{\todo{Spec Result Object}}

\subsection{Error}

{\todo{Spec Error Object}}

\section{Hex Encoding}

Practically, it is more convenient and efficient to store and process data
which is stored in a byte array. On the other hand, the Trie keys are broken
into 4-bits nibbles. Accordingly, we need a method to encode sequences of
4-bits nibbles into byte arrays canonically:

\begin{definition}
  \label{defn-hex-encoding}Suppose that $\tmop{PK} = (k_1, \ldots, k_n)$ is a
  sequence of nibbles, then
  
  \begin{tabular}{l}
    $\tmop{Enc}_{\tmop{HE}} (\tmop{PK}) \assign$\\
    $\left\{ \begin{array}{lll}
      \tmop{Nibbles}_4 & \rightarrow & \mathbb{B}\\
      \tmop{PK} = (k_1, \ldots, k_n) & \mapsto & \left\{ \begin{array}{l}
        \begin{array}{ll}
          (16 k_1 + k_2, \ldots, 16 k_{2 i - 1} + k_{2 i}) & n = 2 i\\
          (k_1, 16 k_2 + k_3, \ldots, 16 k_{2 i} + k_{2 i + 1}) & n = 2 i + 1
        \end{array}
      \end{array} \right.
    \end{array} \right.$
  \end{tabular}
\end{definition}

\chapter{Genesis Block Specification}\label{sect-genisis-block}

\chapter{Predefined Storage Keys}\label{sect-predef-storage-keys}

\chapter{Network Messages}\label{sect-network-messages}

In this section, we will specify various types of messages which Polkadot RE
receives from the network. Furthermore, we also explain the appropriate
responses to those messages.

\begin{definition}
  A {\tmstrong{network message}} is a byte array, {\tmstrong{$M$}} of length
  $\| M \|$ such that:
  
  
  \[ \begin{array}{cc}
       M_1 & \tmop{Message} \tmop{Type} \tmop{Indicator}\\
       M_2 \ldots M_{\| M \|} & \tmop{Enc}_{\tmop{SC}} (\tmop{MessageBody})
     \end{array} \]
  
\end{definition}

The body of each message consists of different components based on its type.
The different possible message types are listed below in Table
\ref{tabl-message-types}. We describe the sub-components of each message type
individually in Section \ref{sect-message-detail}.

\begin{table}[h]
  \begin{tabular}{|c|c|c|}
    \hline
    $M_1$ & Message Type & Description\\
    \hline
    0 & Status & \ref{sect-msg-status}\\
    1 & Block Request & \ref{sect-msg-block-request}\\
    2 & Block Response & \ref{sect-msg-block-response}\\
    3 & Block Announce & \ref{sect-msg-block-announce}\\
    4 & Transactions & \ref{sect-msg-transactions}\\
    5 & Consensus & \ref{sect-msg-consensus}\\
    6 & Remote Call Request & \\
    7 & Remote Call Response & \\
    8 & Remote Read Request & \\
    9 & Remote Read Response & \\
    10 & Remote Header Request & \\
    11 & Remote Header Response & \\
    12 & Remote Changes Request & \\
    13 & Remote Changes Response & \\
    14 & FinalityProofRequest & \\
    15 & FinalityProofResponse & \\
    255 & Chain Specific & \\
    \hline
  \end{tabular}
  \caption{\label{tabl-message-types}List of possible network message types.}
\end{table}

\section{Detailed Message Structure}\label{sect-message-detail}

This section disucsses the detailed structure of each network message.

\subsection{Status Message}\label{sect-msg-status}

A {\tmem{Status}} Message represented by $M_S$ is sent after a connection with
a neighbouring node is established and has the following structure:
\[ M^{}_S \assign \tmop{Enc}_{\tmop{SC}} (v, r, N_B, \tmop{Hash}_B,
   \tmop{Hash}_G, C_S) \]
Where:
{\center{\begin{tabular}{rll}
  $v$: & Protocol version & 32 bit integer\\
  $v_{\min} :$ & Minimum supported version & 32 bit integer\\
  $r$: & Roles & 1 byte\\
  $N_B$: & Best Block Number & 64 bit integer\\
  $\tmop{Hash}_B$ & Best block Hash & $\mathbb{B}_{32}$\\
  $\tmop{Hash}_G$ & Genesis Hash & $\mathbb{B}_{32}$\\
  $C_S$ & Chain Status & Byte array 
\end{tabular}}}


In which, Role is a bitmap value whose bits represent different roles for the
sender node as specified in Table \ref{tabl-node-role}:

\

\begin{center}
  \tmfloat{h}{small}{table}{
  {\center{\begin{tabular}{|r|l|l|}
    \hline
    Value & Binary representation & Role\\
    \hline
    $0$ & 00000000 & No network\\
    1 & 00000001 & Full node, does not participate in consensus\\
    2 & 00000010 & Light client node\\
    4 & 00000100 & Act as an authority \\
    \hline
  \end{tabular}}}
  }{\label{tabl-node-role}Node role representation in the status message.}
\end{center}

\subsection{Block Request Message}\label{sect-msg-block-request}

A Block request message, represented by $M_{\tmop{BR}}$, is sent to request
block data for a range of blocks from a peer and has the following structure:
\[ M^{}_{\tmop{BR}} \assign \tmop{Enc}_{\tmop{SC}} (\tmop{id}, A_B, S_B,
   \tmop{Hash}_E, d, \tmop{Max}) \]
where:
{\center{\begin{tabular}{rll}
  $\tmop{id}$: & Unique request id & 32 bit integer\\
  $A_B$: & Requested data & 1 byte\\
  $S_B$: & Starting Block & Varying \{$\mathbb{B}_{32}, 64 \tmop{bit}
  \tmop{integer}$\}\\
  $\tmop{Hash}_E$ & End block Hash & $\mathbb{B}_{32}$ optional type\\
  $d$ & Block sequence direction & 1 byte\\
  $\tmop{Max}$ & Maximum number of blocks to return & 32 bit integer optional
  type
\end{tabular}}}


\

in which
\begin{itemizeminus}
  \item $A_B$, the requested data, is a bitmap value, whose bits represent the
  part of the block data requested, as explained in Table
  \ref{tabl-block-attributes}:
\end{itemizeminus}
\begin{center}
  \tmfloat{h}{small}{table}{
  {\center{\begin{tabular}{|r|l|l|}
    \hline
    Value & Binary representation & Requested Attribute\\
    \hline
    $1$ & 00000001 & Block header\\
    2 & 00000010 & Block Body\\
    4 & 00000100 & Receipt\\
    8 & 00001000 & Message queue\\
    16 & 00010000 & Justification \\
    \hline
  \end{tabular}}}
  }{\label{tabl-block-attributes}Bit values for block attribute $A_B$, to
  indicate the requested parts of the data.}
\end{center}
\begin{itemizeminus}
  \item $S_B$ is SCALE encoded varying data type (see Definition
  \ref{defn-scale-variable-type}) of either $\mathbb{B}_{32}$ representing the
  block hash, $H_B$, or $64 \tmop{bit}$ integer representing the block number
  of the starting block of the requested range of blocks.
  
  \item $\tmop{Hash}_E$ is optionally the block hash of the last block in the
  range.
  
  \item $d$ is a flag; it defines the direction on the block chain where the
  block range should be considered (starting with the starting block), as
  follows
  \[ d = \left\{ \begin{array}{cc}
       0 & \tmop{child} \tmop{to} \tmop{parent} \tmop{direction}\\
       1 & \tmop{parent} \tmop{to} \tmop{child} \tmop{direction}
     \end{array} \right. \]
\end{itemizeminus}
Optional data type is defined in Definition \ref{defn-varrying-data-type}.

\subsection{Block Response Message}\label{sect-msg-block-response}

A {\tmem{block response message}} represented by $M_{\tmop{BS}}$ is sent in a
response to a requested block message (see Section
\ref{sect-msg-block-request}). It has the following structure:
\[ M^{}_{\tmop{BS}} \assign \tmop{Enc}_{\tmop{SC}} (\tmop{id}, D) \]
where:
{\center{\begin{tabular}{rll}
  $\tmop{id}$: & Unique id of the requested response was made for & 32 bit
  integer\\
  $D$: & Block data for the requested sequence of Block & Array of block data
\end{tabular}}}


\

In which block data is defined in Definition \ref{defn-block-data}.

\begin{definition}
  \label{defn-block-data}{\tmstrong{Block Data}} is defined as the follownig
  tuple:{\todo{Block Data definition should go to block format section}}
\end{definition}
\[ (H_B, \tmop{Header}_B, \tmop{Body}, \tmop{Receipt}, \tmop{MessageQueue},
   \tmop{Justification}) \]
Whose elements, with the exception of $H_B$, are all of the following
{\tmem{optional type}} (see Definition \ref{defn-varrying-data-type}) and are
defined as follows:
{\center{\begin{tabular}{rll}
  $H_B$: & Block header hash & $\mathbb{B}_{32}$\\
  $\tmop{Header}_B$: & Block header & 5-tuple (Definition
  \ref{defn-block-header})\\
  Body & Array of extrinsics & Array of Byte arrays (Section
  \ref{sect-extrinsics})\\
  Receipt & Block Receipt & Byte array\\
  Message Queue & Block message queue & Byte array\\
  Justification & Block Justification & Byte array
\end{tabular}}}


\subsection{Block Announce Message}\label{sect-msg-block-announce}

A {\tmem{block announce message}} represented by $M_{\tmop{BA}}$ is sent when
a node becomes aware of a new complete block on the network and has the
following structure:
\[ M_{\tmop{BA}} \assign \tmop{Enc}_{\tmop{SC}} (\tmop{Header}_B) \]
Wh\tmverbatim{}ere:
{\center{\begin{tabular}{rll}
  $\tmop{Header}_B$: & Header of new block B & 5-tuple header (Definition
  \ref{defn-block-header})
\end{tabular}}}
\subsection{Transactions}\label{sect-msg-transactions}

\ \ \ The transactions Message is represented by $M_T$ and is defined as
follows:
\[ M_T \assign \tmop{Enc}_{\tmop{SC}} (C_1, \ldots, C_n) \]
in which:
\[ C_i \assign \tmop{Enc}_{\tmop{SC}} (E_i) \]
Where each $E_i$ is a byte array and represents a sepearate extrinsic.
Polkadot RE is indifferent about the content of an extrinsic and treats it as
a blob of data.

\subsection{Consensus Message}\label{sect-msg-consensus}

A {\tmem{consensus message}} represented by $M_C$ is sent to communicate
messages related to consensus process:
\[ M_C \assign \tmop{Enc}_{\tmop{SC}} (E_{\tmop{id}}, D) \]
Wh\tmverbatim{}ere:
{\center{\begin{tabular}{rll}
  $E_{\tmop{id}}$: & The consensus engine unique identifier & $\mathbb{B}_4$\\
  $D$ & Consensus message payload & $\mathbb{B}$
\end{tabular}}}


in which
\[ E_{\tmop{id}} \assign \left\{ \begin{array}{ccc}
     '' \tmop{BABE}'' &  & \tmop{For} \tmop{messages} \tmop{related} \tmop{to}
     \tmop{BABE} \tmop{protocol}\\
     '' \tmop{FRNK}'' &  & \tmop{For} \tmop{messages} \tmop{related} \tmop{to}
     \tmop{GRANDPA} \tmop{protocol}
   \end{array} \right. \]


The network agent should hand over $D$ to approperiate consensus engine which
identified by $E_{\tmop{id}}$.

\chapter{Runtime Environment API\label{sect-re-api}}

The Runtime Environment API is a set of functions that Polkadot RE exposes to
Runtime to access external functions needed for various reasons, such as the
Storage of the content, access and manipulation, memory allocation, and also
efficiency. We introduce Notation \ref{nota-re-api-at-state} to emphasize that
the result of some of the API functions depends on the content of state
storage.

\begin{notation}
  \label{nota-re-api-at-state}By $\mathcal{R}\mathcal{E}_B$ we refer to the
  API exposed by Polkadot RE which interact, manipulate and response based on
  the state storage whose state is set at the end of the execution of block
  $B$.
\end{notation}

The functions are specified in each subsequent subsection for each category
of those functions.

\section{Storage}

\subsection{\tmverbatim{ext\_set\_storage}}

Sets the value of a specific key in the state storage.

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_storage
  (param $key_data i32) (param $key_len i32) (param $value_data i32)                           (param $value_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key}: a pointer indicating the buffer containing the key.
  
  \item \tmverbatim{key\_len}: the key length in bytes.
  
  \item \tmverbatim{value}: a pointer indicating the buffer containing the
  value to be stored under the key.
  
  \item \tmverbatim{value\_len}: \ the length of the value buffer in bytes.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_root}}

Retrieves the root of the state storage.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_storage_root
  (param $result_ptr i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{result\_ptr}: a memory address pointing at a byte array
  which contains the root of the state storage after the function concludes.
\end{itemize}

\subsubsection{\tmverbatim{ext\_blake2\_256\_enumerated\_trie\_root}}

Given an array of byte arrays, it arranges them in a Merkle trie, defined
in\tmverbatim{{\tmem{{\tmstrong{}}}}} Section \ref{sect-merkl-proof}, where
the key under which the values are stored is the 0-based index of that value
in the array. It computes and returns the root hash of the constructed trie.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_blake2_256_enumerated_trie_root
      (param $values_data i32) (param $lens_data i32) (param $lens_len i32) 
      (param $result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{values\_data}: a memory address pointing at the buffer
  containing the array where byte arrays are stored consecutively.
  
  \item \tmverbatim{lens\_data}: an array of \tmverbatim{i32} elements each
  stores the length of each byte array stored in \tmverbatim{value\_data}.
  
  \item \tmverbatim{len}s\_len: the number of \tmverbatim{i32} elements in
  \tmverbatim{lens\_data}.
  
  \item \tmverbatim{result}: a memory address pointing at the beginning of a
  32-byte byte array containing the root of the Merkle trie corresponding to
  elements of \tmverbatim{values\_data}.
\end{itemize}

\subsection{\tmverbatim{ext\_clear\_prefix}}

Given a byte array, this function removes all storage entries whose key
matches the prefix specified in the array.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_clear_prefix
      (param $prefix_data i32) (param $prefix_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{prefix\_data}: a memory address pointing at the buffer
  containing the byte array containing the prefix.
  
  \item \tmverbatim{prefix\_len}: the length of the byte array in number of
  bytes.
\end{itemize}

\subsection{\tmverbatim{}\tmverbatim{ext\_clear\_storage}}

Given a byte array, this function removes the storage entry whose key is
specified in the array.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_clear_storage
      (param $key_data i32) (param $key_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer
  containing the byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the byte array in number of
  bytes.
\end{itemize}

\subsubsection{\tmverbatim{ext\_exists\_storage}}

Given a byte array, this function checks if the storage entry corresponding to
the key specified in the array exists.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_exists_storage
      (param $key_data i32) (param $key_len i32) (result i32)
    )
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer
  containing the byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the byte array in number of
  bytes.
  
  \item \tmverbatim{result}: An \tmverbatim{i32} integer which is equal to 1
  verifies if an entry with the given key exists in the storage or 0 if the
  key storage does not contain an entry with the given key.
\end{itemize}

\subsection{\tmverbatim{ext\_get\_allocated\_storage}}

Given a byte array, this function allocates a large enough buffer in the
memory and retrieves the value stored under the key that is specified in the
array. Then, it stores it in the allocated buffer if the entry exists in the
storage.

\

{\tmstrong{Prototype:}}
\begin{alltt}
    (func $get_allocated_storage
      (param $key_data i32) (param $key_len i32) (param $written_out i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer
  containing the byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the byte array in number of
  bytes.
  
  \item \tmverbatim{written\_out}: the function stores the length of the
  retrieved value in number of bytes if the enty exists. If the entry does not
  exist, it returns $2^{32} - 1$.
  
  \item \tmverbatim{result}: A pointer to the buffer in which the function
  allocates and stores the value corresponding to the given key if such an
  entry exist; otherwise it is equal to 0.
\end{itemize}

\subsection{\tmverbatim{ext\_get\_storage\_into}}

Given a byte array, this function retrieves the value stored under the key
specified in the array and stores a specified chunk of it in the provided
buffer, if the entry exists in the storage.

\

{\tmstrong{Prototype:}}
\begin{alltt}
    (func $ext_get_storage_into 
      (param $key_data i32) (param $key_len i32) (param $value_data i32)
      (param $value_len i32) (param $value_offset i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer
  containing the byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the byte array in number of
  bytes.
  
  \item \tmverbatim{value\_data}: a pointer to the buffer in which the
  function stores the chunk of the value it retrieves.
  
  \item \tmverbatim{value\_len}: the (maximum) length of the chunk in bytes
  the function will read of the value and will store in the
  \tmverbatim{value\_data} buffer.
  
  \item \tmverbatim{value\_offset}: the offset of the chunk where the function
  should start storing the value in the provided buffer, i.e. the number of
  bytes the functions should skip from the retrieved value before storing the
  data in the \tmverbatim{value\_data} in number of bytes.
  
  \item \tmverbatim{result}: The number of bytes the function writes in
  \tmverbatim{value\_data} if the value exists or $2^{32} - 1$ if the entry
  does not exist under the specified key.
\end{itemize}

\subsection{To Be Specced}

\begin{itemize}
  \item \tmverbatim{ext\_clear\_child\_storage}
  
  \item \tmverbatim{ext\_exists\_child\_storage}
  
  \item \tmverbatim{ext\_get\_allocated\_child\_storage}
  
  \item \tmverbatim{ext\_get\_child\_storage\_into}
  
  \item \tmverbatim{ext\_kill\_child\_storage}
  
  \item \tmverbatim{ext\_set\_child\_storage}
  
  \item \tmverbatim{ext\_storage\_changes\_root}
\end{itemize}

\subsection{Memory}

\subsubsection{\tmverbatim{ext\_malloc}}

Allocates memory of a requested size in the heap.

\

{\tmstrong{Prototype}}:
\begin{alltt}
(func $ext_malloc
  (param $size i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{size:} the size of the buffer to be allocated in number of
  bytes. 
\end{itemize}


{\tmstrong{Result}}:
\begin{itemize}
  a memory address pointing at the beginning of the allocated buffer.
\end{itemize}

\subsubsection{\tmverbatim{ext\_free}}

Deallocates a previously allocated memory.

\

{\tmstrong{Prototype}}:
\begin{alltt}
(func $ext_free
      (param $addr i32))
\end{alltt}


{\tmstrong{Arguments:}}
\begin{itemize}
  \item \tmverbatim{addr}: a 32bit memory address pointing at the allocated
  memory.
\end{itemize}

\subsubsection{Input/Output}

\begin{itemize}
  \item \tmverbatim{ext\_print\_hex}
  
  \item \tmverbatim{ext\_print\_num}
  
  \item \tmverbatim{ext\_print\_utf8}
\end{itemize}

\subsection{Cryptograhpic Auxiliary Functions}

\subsubsection{\tmverbatim{ext\_blake2\_256}}

Computes the Blake2b 256bit hash of a given byte array.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func (export "ext_blake2_256")
      (param $data i32) (param  $len i32) (param $out i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a memory address pointing at the buffer containing
  the byte array to be hashed.
  
  \item \tmverbatim{len}: the length of the byte array in bytes.
  
  \item \tmverbatim{out}: a memory address pointing at the beginning of a
  32-byte byte array contanining the Blake2b hash of the data.
\end{itemize}

\subsubsection{\tmverbatim{ext\_keccak\_256}}

Computes the Keccak-256 hash of a given byte array.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_keccak_256
      (param $data i32) (param $len i32) (param $out i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a memory address pointing at the buffer containing
  the byte array to be hashed.
  
  \item \tmverbatim{len}: the length of the byte array in bytes.
  
  \item \tmverbatim{out}: a memory address pointing at the beginning of a
  32-byte byte array contanining the Keccak-256 hash of the data.
\end{itemize}

\subsubsection{\tmverbatim{ext\_twox\_128}}

Computes the {\tmem{xxHash64}} algorithm (see {\cite{collet_extremely_2019}})
twice initiated with seeds 0 and 1 and applied on a given byte array and
outputs the concatenated result.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_twox_128
       (param $data i32) (param $len i32) (param $out i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a memory address pointing at the buffer containing
  the byte array to be hashed.
  
  \item \tmverbatim{len}: the length of the byte array in bytes.
  
  \item \tmverbatim{out}: a memory address pointing at the beginning of a
  16-byte byte array containing \ {\tmem{$\text{xxhash}
  64_0$}}(\tmverbatim{data})\textbar\textbar{\tmem{$\text{xxhash64}_1$}}(\tmverbatim{data})
  where {\tmem{$\text{xxhash} 64_i$}} is the xxhash64 function initiated with
  seed $i$ as a 64bit unsigned integer.
\end{itemize}

\subsubsection{\tmverbatim{ext\_ed25519\_verify}}

Given a message signed by the ED25519 signature algorithm alongside with its
signature and the allegedly signer public key, it verifies the validity of the
signature by the provided public key.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_ed25519_verify
      (param $msg_data i32) (param $msg_len i32) (param $sig_data i32)
      (param $pubkey_data i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{msg\_data}: a pointer to the buffer containing the message
  body.
  
  \item \tmverbatim{msg\_len}: an \tmverbatim{i32} integer indicating the size
  of the message buffer in bytes.
  
  \item \tmverbatim{sig\_data}: a pointer to the 64 byte memory buffer
  containing the ED25519 signature corresponding to the message.
  
  \item \tmverbatim{pubkey\_data}: a pointer to the 32 byte buffer containing
  the public key and corresponding to the secret key which has signed the
  message.
  
  \item \tmverbatim{result}: \ an in\tmverbatim{}teger value equal to 0
  indicating the validity of the signature or a nonzero value otherwise.
\end{itemize}

\subsubsection{\tmverbatim{ext\_sr25519\_verify}}

Given a message signed by the SR25519 signature algorithm alongside with its
signature and the allegedly signer public key, it verifies the validity of the
signature by the provided public key.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_sr25519_verify
      (param $msg_data i32) (param $msg_len i32) (param $sig_data i32)
      (param $pubkey_data i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{msg\_data}: a pointer to the buffer containing the message
  body.
  
  \item \tmverbatim{msg\_len}: an \tmverbatim{i32} integer indicating the size
  of the message buffer in bytes.
  
  \item \tmverbatim{sig\_data}: a pointer to the 64 byte memory buffer
  containing the SR25519 signature corresponding to the message.
  
  \item \tmverbatim{pubkey\_data}: a pointer to the 32 byte buffer containing
  the public key and corresponding to the secret key which has signed the
  message.
  
  \item \tmverbatim{result}: \ an in\tmverbatim{}teger value equal to 0
  indicating the validity of the signature or a nonzero value otherwise.
\end{itemize}

\subsubsection{To be Specced}

\begin{itemize}
  \item \tmverbatim{ext\_twox\_256}
\end{itemize}

\subsection{Offchain Worker }

\subsubsection{\tmverbatim{ext\_submit\_transaction}}

Given an extrinsic as a SCALE encoded byte array, the system decodes the byte
array and submits the extrinsic in the inherent pool as an extrinsic to be
included in the next produced block.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_submit_transaction
      (param $data i32) (param $len i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer to the buffer containing the byte array
  storing the encoded extrinsic.
  
  \item \tmverbatim{len}: an \tmverbatim{i32} integer indicating the size of
  the encoded extrinsic.
  
  \item \tmverbatim{result}: \ an in\tmverbatim{}teger value equal to 0
  indicates that the extrinsic is successfully added to the pool or a nonzero
  value otherwise.
\end{itemize}

\subsection{Sandboxing}

\subsubsection{To be Specced}

\begin{itemize}
  \item \tmverbatim{ext\_sandbox\_instance\_teardown}
  
  \item \tmverbatim{ext\_sandbox\_instantiate}
  
  \item \tmverbatim{ext\_sandbox\_invoke}
  
  \item \tmverbatim{ext\_sandbox\_memory\_get}
  
  \item \tmverbatim{ext\_sandbox\_memory\_new}
  
  \item \tmverbatim{ext\_sandbox\_memory\_set}
  
  \item \tmverbatim{ext\_sandbox\_memory\_teardown}
\end{itemize}

\subsection{Auxillary Debugging API}

\subsubsection{\tmverbatim{ext\_print\_hex}}

Prints out the content of the given buffer on the host's debugging console.
Each byte is represented as a two-digit hexadecimal number.

\

{\tmstrong{Prototype:}}
\begin{alltt}
    (func $ext_print_hex
      (param $data i32) (parm $len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer to the buffer containing the data that
  needs to be printed.
  
  \item \tmverbatim{len}: an \tmverbatim{i32} integer indicating the size of
  the buffer containing the data in bytes.
\end{itemize}

\subsubsection{\tmverbatim{ext\_print\_utf8}}

Prints out the content of the given buffer on the host's debugging console.
The buffer content is interpreted as a UTF-8 string if it represents a valid
UTF-8 string, otherwise does nothing and returns.

{\tmstrong{Prototype:}}o
\begin{alltt}
    (func $ext_print_utf8
      (param $utf8_data i32) (param $utf8_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{utf8\_data}: a pointer to the buffer containing the
  utf8-encoded string to be printed.
  
  \item \tmverbatim{utf8\_len}: an \tmverbatim{i32} integer indicating the
  size of the buffer containing the UTF-8 string in bytes.
\end{itemize}

\subsection{Misc}

\subsubsection{To be Specced}
\begin{itemizedot}
  \item \tmverbatim{ext\_chain\_id}
\end{itemizedot}
\tmverbatim{}\subsection{Block Production}

\section{Validation}

\

\chapter{Runtime Entries}\label{sect-runtime-entries}

\section{List of Runtime Entries}\label{sect-list-of-runtime-entries}

Polkadot RE assumes that at least the following functions are implemented in
the Runtime Wasm blob and have been exported as shown in Snippet
\ref{snippet-runtime-enteries}:

\tmfloat{h}{small}{figure}{\begin{tmcode}[cpp]
  (export "Core_version" (func $Core_version))
  (export "Core_execute_block" (func $Core_execute_block))
  (export "Core_initialize_block" (func $Core_initialize_block))
  (export "Metadata_metadata" (func $Metadata_metadata))
  (export "BlockBuilder_apply_extrinsic" (func $BlockBuilder_apply_extrinsic))
  (export "BlockBuilder_finalize_block" (func $BlockBuilder_finalize_block))
  (export "BlockBuilder_inherent_extrinsics" 
          (func $BlockBuilder_inherent_extrinsics))
  (export "BlockBuilder_check_inherents" (func $BlockBuilder_check_inherents))
  (export "BlockBuilder_random_seed" (func $BlockBuilder_random_seed))
  (export "TaggedTransactionQueue_validate_transaction" 
          (func $TaggedTransactionQueue_validate_transaction))
  (export "OffchainWorkerApi_offchain_worker" 
          (func $OffchainWorkerApi_offchain_worker))
  (export "ParachainHost_validators" (func $ParachainHost_validators))
  (export "ParachainHost_duty_roster" (func $ParachainHost_duty_roster))
  (export "ParachainHost_active_parachains" 
          (func $ParachainHost_active_parachains))
  (export "ParachainHost_parachain_status" (func $ParachainHost_parachain_status))
  (export "ParachainHost_parachain_code" (func $ParachainHost_parachain_code))
  (export "ParachainHost_ingress" (func $ParachainHost_ingress))
  (export "GrandpaApi_grandpa_pending_change" 
          (func $GrandpaApi_grandpa_pending_change))
  (export "GrandpaApi_grandpa_forced_change" 
          (func $GrandpaApi_grandpa_forced_change))
  (export "GrandpaApi_grandpa_authorities" (func $GrandpaApi_grandpa_authorities))
  (export "BabeApi_startup_data" (func $BabeApi_startup_data))
  (export "BabeApi_epoch" (func $BabeApi_epoch))
  (export "SessionKeys_generate_session_keys" 
          (func $SessionKeys_generate_session_keys))

\end{tmcode}}{\label{snippet-runtime-enteries}Snippet to export entries into
tho Wasm runtime module.}

The following sections describe the standard based on which Polkadot RE
communicates with each runtime entry.

\section{Argument Specification}

As a wasm functions, all runtime entries have the following prototype
signature:
\begin{alltt}
    (func $generic_runtime_entry
      (param $data i32) (parm $len i32) (reslut i64))
\end{alltt}
where \tmverbatim{data} points to the SCALE encoded paramaters sent to the
function and \tmverbatim{len} is the length of the data. \tmverbatim{result}
can similarly either point to the SCALE encoded data the function returns or
represent a boolean value (See Sections
\ref{sect-runtime-send-args-to-runtime-enteries} and
\ref{sect-runtime-return-value}).

In this section, we describe the function of each of the entries alongside
with the details of the SCALE encoded arguments and the return values for each
one of these enteries.

\subsection{\tmverbatim{Core\_version}}

This entry receives no argument; it returns the version data encoded in ABI
format described in Section \ref{sect-runtime-return-value} containing the
following information:

\

\begin{center}
  \tmfloat{h}{small}{table}{\begin{tabular}{lll}
    \hline
    Name & Type & Description\\
    \hline
    \tmverbatim{spec\_name} & String & Runtime identifier\\
    \tmverbatim{impl\_name} & String & the name of the implementation (e.g.
    C++)\\
    \tmverbatim{authoring\_version} & UINT32 & the version of the authorship
    interface\\
    \tmverbatim{spec\_version} & UINT32 & the version of the Runtime
    specification\\
    \tmverbatim{impl\_version} & UINT32 & the version of the Runtime
    implementation\\
    \tmverbatim{apis} & ApisVec & List of supported AP\\
    \hline
  \end{tabular}}{Detail of the version data type returns from runtime
  \tmverbatim{version} function.}
\end{center}

\subsection{\tmverbatim{Core\_execute\_block}}

This entry is responsible for executing all extrinsics in the block and
reporting back if the block was successfully executed.

{\tmstrong{Arguments}}:
\begin{itemize}
  \item The entry accepts the {\tmem{block data}} defined in Definition
  \ref{defn-block-data} as the only argument.
\end{itemize}


{\tmstrong{Return}}:

A Boolean value indicates if the execution was successful.

\subsection{\tmverbatim{Core\_initialise\_block}}

{\todo{Spec initialize block}}

\subsection{\tmverbatim{hash\_and\_length}}\label{sect-rte-hash-and-length}

An auxilarry function which returns hash and encoding length of an extrinsics.

{\tmstrong{Arguments}}:
\begin{itemize}
  \item A SCALE encoded blob of an extrinsic.
\end{itemize}


{\tmstrong{Return}}:

Pair of Blake2Hash of the blob as element of $\mathbb{B}_{32}$ and its length
as 64 bit integer.

\subsection{\tmverbatim{BabeApi\_epoch}}\label{sect-rte-validate-transaction}

This entry is called to obtain the current configuration of BABE consensus
protocol.

{\tmstrong{Arguments}}:
\begin{itemize}
  \item $H_n (B)$: the block number at whose final state the epoch
  configuration should be obtained.
\end{itemize}


{\tmstrong{Return}}:

A tuple
\[ (\mathcal{E}_n, s^n_0, \tmop{sc}_n, A, \rho, \tmop{Sec}) \]


where:
{\center{\begin{tabular}{rll}
  $\mathcal{E}_n$: & epoch index (see Definition \ref{defn-epoch-slot}) &
  64-bit integer\\
  $s^n_0 :$ & The index of the starting slot of $\mathcal{E}_n$ & 64-bit
  integer\\
  $\tmop{sc}_n$: & Slot count of $\mathcal{E}_n$ (see Definition
  \ref{defn-epoch-slot}) & 1 byte\\
  $A$: & The list of authorities and their weights & Array of $(P_A, W_A)$\\
  $\rho$ & Randomness used in $\mathcal{E}_n$ (see Section
  \ref{sect-epoch-randomness}) & $\mathbb{B}_{32}$\\
  Sec & To be specced & Boolean
\end{tabular}}}


in which:
{\center{\begin{tabular}{rll}
  $P_A$: & The public key of authority A & $\mathbb{B}_{32}$\\
  $W_A :$ & The weight of the authority A & 64 bit integer
\end{tabular}}}


\subsection{\tmverbatim{Grandpa\_authorities}}\label{sect-rte-grandpa-auth}

This entry is to report the set of GRANDPA voters at a given block. It
receives \tmverbatim{block\_id} as an argument; it returns an array of
\tmverbatim{authority\_id}'s.

\subsection{\tmverbatim{TaggedTransactionQueue\_validate\_transaction}}\label{sect-rte-validate-transaction}

This entry is invoked against extrinsics submitted through the Transaction
network message \ref{sect-msg-transactions} and indicates if the submitted
blob represents a valid extrinsics applied to the specified block.

{\tmstrong{Arguments}}:
\begin{itemize}
  \item $H_n (B)$: the block number whose final state is where the transaction
  should apply the system state.
  
  \item UTX: A byte array that contains the SCALE encoded transaction.
\end{itemize}


{\tmstrong{Return}}:

A varying type Result object which has type of {\tmem{TransactionValidity}} in
case no error occurs in course of its execution. TransactionValidity is of
varying type described in the Table \ref{tabl-transaction-validity}:

\

\tmfloat{h}{small}{table}{\begin{tabular}{lll}
  Type Index & Data type & Description\\
  0 & Byte & Indicating invalid extrinsic and bearing the error code
  concerning\\
  &  & the cause of invalidity of the transaction.\\
  1 & A Quin-tuple & Indicating whether the extrinsic is valid and providing
  guidance for \\
  &  & Polkadot RE on how to proceed with the extrinsic (see below)\\
  2 & Byte & The Validity of the extrinsic cannot be determined
\end{tabular}}{\label{tabl-transaction-validity}Type variation for the return
value of \tmverbatim{TaggedTransactionQueue\_transaction\_validity}.}

\

In which the quintuple of type for valid extrinsics consists of the following
parts:
\[ (\tmop{priority}, \tmop{requires}, \tmop{provides}, \tmop{longevity},
   \tmop{propagate}) \]


\tmfloat{h}{small}{table}{\begin{tabular}{lll}
  Name & Description & Type\\
  Priority & Determines the ordering of two transactions that have & 64bit
  integer\\
  & all their dependencies (required tags) satisfied. & \\
  Requires & List of tags specifying extrinsics which should be applied  &
  Array of \\
  & before the current exrinsics can be applied. & Transaction Tags\\
  Provides & Informs Runtime of the extrinsics depending on the tags in &
  Array of \\
  & the list that can be applied after current extrinsics are being applied.
  & Transaction Tags\\
  & Describes the minimum number of blocks for the validity to be correct &
  \\
  Longevity & After this period, the transaction should be removed from the  &
  64 bit integer\\
  & pool or revalidated. & \\
  Propagate & A flag indicating if the transaction should be propagated to  &
  Boolean\\
  & other peers. & 
\end{tabular}}{The quintuple provided by
\tmverbatim{TaggedTransactionQueue\_transaction\_validity}
in the case the transaction is judged to be valid.}

\

Note that if {\tmem{Propagate}} is set to \tmverbatim{false} the transaction
will still be considered for including in blocks that are authored on the
current node, but will never be sent to other peers.

\begin{thebibliography}{DGKR18}
  \bibitem[Ali19]{alistair_stewart_grandpa:_2019}Alistair Stewart.
  {\newblock}GRANDPA: A Byzantine Finality Gadgets, 2019.
  
  \bibitem[Col19]{collet_extremely_2019}Yann Collet. {\newblock}Extremely fast
  non-cryptographic hash algorithm. {\newblock}Technical report, -,
  http://cyan4973.github.io/xxHash/, 2019.
  
  \bibitem[DGKR18]{david_ouroboros_2018}Bernardo David, Peter Ga{\v z}i,
  Aggelos Kiayias, and Alexander Russell. {\newblock}Ouroboros praos: An
  adaptively-secure, semi-synchronous proof-of-stake blockchain. {\newblock}In
  \tmtextit{Annual International Conference on the Theory and Applications of
  Cryptographic Techniques}, pages 66--98. Springer, 2018.
  
  \bibitem[Gro19]{w3f_research_group_blind_2019}W3F~Research Group.
  {\newblock}Blind Assignment for Blockchain Extension. {\newblock}Technical
  Specification, Web 3.0 Foundation,
  http://research.web3.foundation/en/latest/polkadot/BABE/Babe/, 2019.
  
  \bibitem[SA15]{saarinen_blake2_2015}Markku~Juhani Saarinen and Jean-Philippe
  Aumasson. {\newblock}The BLAKE2 cryptographic hash and message
  authentication code (MAC). {\newblock}RFC 7693,
  https://tools.ietf.org/html/rfc7693, 2015.
\end{thebibliography}

\printindex

\end{document}

